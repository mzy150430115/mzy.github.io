<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/12/06/springcloud/spring%20cloud%20config/"/>
    <url>/2021/12/06/springcloud/spring%20cloud%20config/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个只会写代码撸猫的废物研究生</title>
    <link href="/2021/12/06/hello-world/"/>
    <url>/2021/12/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>我是一名来自江苏的Boy，本科毕业于南京工程学院，目前在辽宁科技大学读研，同时现也就职于某云计算大厂~</p><p>喜欢研究技术，热爱编程，欢迎交流分享编程技术~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo学习笔记</title>
    <link href="/2021/12/06/Dubbo/dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/12/06/Dubbo/dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo学习笔记"><a href="#Dubbo学习笔记" class="headerlink" title="Dubbo学习笔记"></a>Dubbo学习笔记</h1><h2 id="（一）-Dubbo出现的背景"><a href="#（一）-Dubbo出现的背景" class="headerlink" title="（一） Dubbo出现的背景"></a>（一） Dubbo出现的背景</h2><p><img src="images/image-20200727144951412.png" alt="image-20200727144951412"></p><p>单体应用<br>    所有功能都在一个应用之中，机器数量在1-10之间</p><p>垂直应用<br>    将应用按照功能进行划分，拆分成互不相干的小应用，应用之间应该没有交互</p><p>分布式应用<br>    “合久必分”，虽然提供的是独立的服务，但是可以被其他应用或服务所调用。<br>     SOA = Service-Oriented Architecture 面向服务的架构<br>     通过定义接口，来提供调用方式，实际执行逻辑是被调用服务（项目B）中编写的代码</p><p>​     项目A    AService     –&gt;   项目B    BService   sayHello(String  msg)</p><p>​     </p><p>​     早期的SOA实现方式：<br>​     1）WebService  (注册、发现、调用)<br>​     此时通信的数据格式为xml，通信协议也多是http或者https</p><img src="images/image-20200727155720567.png" alt="image-20200727155720567" style="zoom:80%;" /><p>​      2）ESB  = Enterprise Service Bus  企业服务总线<br>​      通过管道，将各服务进行整合，以更好的通信 </p><img src="images/image-20200727160905768.png" alt="image-20200727160905768" style="zoom:80%;" /><h2 id="（二）-分布式系统通信方式"><a href="#（二）-分布式系统通信方式" class="headerlink" title="（二） 分布式系统通信方式"></a>（二） 分布式系统通信方式</h2><h3 id="1、RMI"><a href="#1、RMI" class="headerlink" title="1、RMI"></a>1、RMI</h3><p>RMI = Remote  Method Invocation 远程方法调用</p><img src="images/image-20200727214523965.png" alt="image-20200727214523965" style="zoom:80%;" /><p>客户端将要调用的方法及参数，打包为辅助对象，通过网络socket，发送给服务端辅助对象；<br>服务端接收后，会进行解包，找出真正被调用的方法，然后将执行结果，依次再返回回去；<br>服务端辅助对象进行打包，然后客户端辅助对象进行解包，结果返回给真正的调用者。</p><h3 id="2、RPC"><a href="#2、RPC" class="headerlink" title="2、RPC"></a>2、RPC</h3><p>IPC =  Inter-Process Communication   进程间通信<br>进程是计算机系统分配资源的最小单位，对于每个进程而言，都是资源隔离的<br>通信是解决，不同进程间相互访问资源的需求</p><p>LPC = Local Procedure Call 本地过程调用<br>RPC = Remote Procedure Call 远程过程调用</p><p>RPC真正的目的，是像调用本地方法一样去调用远程方法，而且不需要关心方法部署在哪里，这样才能够解耦服务。</p><p>简单说，RPC就是从一台机器通过参数传递的方式，调用另一台机器上的方法，并得到返回结果。</p><p>【常用RPC框架】</p><p>1） Dubbo，阿里开发，基于Spring和Netty，是当前使用最广泛的RPC框架<br>2） brpc，百度开发，“baidu-rpc”，支持多种协议，性能优良<br>3） grpc，谷歌开发，基于Netty，在人工智能领域有广泛应用，服务于tensorflow的底层通信<br>4） Thrift，脸书开发，已开源给apache，有一定的应用范围</p><h2 id="（三）Dubbo"><a href="#（三）Dubbo" class="headerlink" title="（三）Dubbo"></a>（三）Dubbo</h2><h3 id="1、Dubbo架构图"><a href="#1、Dubbo架构图" class="headerlink" title="1、Dubbo架构图"></a>1、Dubbo架构图</h3><img src="images/image-20200728003943692.png" alt="image-20200728003943692" style="zoom:80%;" /><p>服务的提供者、注册中心、服务的消费者、服务的监听</p><h3 id="2、注册中心-Zookeeper"><a href="#2、注册中心-Zookeeper" class="headerlink" title="2、注册中心 - Zookeeper"></a>2、注册中心 - Zookeeper</h3><p>最早由雅虎开发，用来解决分布式系统中的一致性问题。<br>包括配置管理、集群的扩容和缩容、分布式锁等等。</p><p>1） 官网下载安装包，将tar.gz文件解压缩<br>2） Zookeeper也需使用本地的java环境，java_home的地址不能包含特殊字符，如中文或括号等等<br>3） 在本地找到一个存放zookeeper的地址，然后进入conf目录下，拷贝一份zoo_sample.cfg，命名为zoo.cfg</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># The number of milliseconds of each tick</span><br><span class="hljs-meta"># tick是zookeeper计时的时间单位   这里表示2000ms = 2s</span><br>tickTime=<span class="hljs-number">2000</span><br><span class="hljs-meta"># The number of ticks that the initial </span><br><span class="hljs-meta"># synchronization phase can take</span><br>initLimit=<span class="hljs-number">10</span><br><span class="hljs-meta"># The number of ticks that can pass between </span><br><span class="hljs-meta"># sending a request and getting an acknowledgement</span><br><span class="hljs-meta"># 同步限制时间 （心跳时间）  单位是5tick = 10s</span><br>syncLimit=<span class="hljs-number">5</span><br><span class="hljs-meta"># the directory where the snapshot is stored.</span><br><span class="hljs-meta"># do not use /tmp for storage, /tmp here is just </span><br><span class="hljs-meta"># example sakes.</span><br><span class="hljs-meta"># 存放数据的目录地址   存放日志的地址  dataLogDir</span><br>dataDir=/tmp/zookeeper<br><span class="hljs-meta"># the port at which the clients will connect</span><br><span class="hljs-meta"># 客户端连接zookeeper的端口号</span><br>clientPort=<span class="hljs-number">2181</span><br><span class="hljs-meta"># the maximum number of client connections.</span><br><span class="hljs-meta"># increase this if you need to handle more clients</span><br><span class="hljs-meta">#maxClientCnxns=60</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># Be sure to read the maintenance section of the </span><br><span class="hljs-meta"># administrator guide before turning on autopurge.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># The number of snapshots to retain in dataDir</span><br><span class="hljs-meta">#autopurge.snapRetainCount=3</span><br><span class="hljs-meta"># Purge task interval in hours</span><br><span class="hljs-meta"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="hljs-meta">#autopurge.purgeInterval=1</span><br><br><span class="hljs-meta">## Metrics Providers</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># https://prometheus.io Metrics Exporter</span><br><span class="hljs-meta">#metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="hljs-meta">#metricsProvider.httpPort=7000</span><br><span class="hljs-meta">#metricsProvider.exportJvmInfo=true</span><br><br></code></pre></td></tr></table></figure><p>4） 启动服务并验证可以被连接<br>       进入到bin目录下，执行zkServer.cmd，  启动成功后，再打开新的窗口，同样在bin目录下，执行zkCli.cmd，可以看到命令行窗口。</p><p>【zookeeper命令】</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">查看目录结构的命令    <span class="hljs-keyword">ls</span> /<br>获取对应目录的值      get <span class="hljs-string">/dubbo</span><br><br>退出命令  <span class="hljs-keyword">quit</span><br></code></pre></td></tr></table></figure><h3 id="3、HelloWorld"><a href="#3、HelloWorld" class="headerlink" title="3、HelloWorld"></a>3、HelloWorld</h3><p>1） demo – spring方式集成</p><p>提供一个可被调用的接口<br>提供方，实现接口的方法逻辑，启动应用程序，接收消费方的调用<br>消费方，确认要调用的接口，找到注册中心，调用提供方，获取接口的返回结果</p><p>a、启动zookeeper<br>b、引入相关依赖<br>c、声明接口及其实现类<br>d、创建提供方和消费方的应用程序</p><p>2） demo – springboot方式集成</p><p>a、引入依赖（dubbo-springboot、 dubbo-zookeeper、要使用的api的依赖）<br>b、实现provider， 实现接口逻辑，增加配置参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 说明这个类是作为dubbo的服务被调用的</span><br><span class="hljs-meta">@DubboService</span>(version = <span class="hljs-string">&quot;1.0.0&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 配置dubbo涉及的相关参数</span><br><span class="hljs-attr">spring.application.name</span>=dubbo-demo-provider<br><span class="hljs-comment"># 配置dubbo服务的扫描路径</span><br><span class="hljs-attr">dubbo.scan.base-packages</span>=com.duing.provider.service<br><br><span class="hljs-comment"># dubbo协议相关信息</span><br><span class="hljs-attr">dubbo.protocol.name</span>=dubbo<br><span class="hljs-attr">dubbo.protocol.port</span>=<span class="hljs-number">2345</span><br><br><span class="hljs-comment"># dubbo注册中心地址</span><br><span class="hljs-attr">dubbo.registry.address</span>=zookeeper://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">2181</span><br></code></pre></td></tr></table></figure><p>c、实现consumer，注意配置类和主程序入口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboDemoConsumerApplication</span> </span>&#123;<br><br>    <span class="hljs-comment">// 对于调用端  使用的注解为DubboReference</span><br>    <span class="hljs-comment">// 对于提供端  使用的注解为DubboService</span><br>    <span class="hljs-meta">@DubboReference</span>(version = <span class="hljs-string">&quot;1.0.0&quot;</span>)<br>    <span class="hljs-keyword">private</span> DemoService demoService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        SpringApplication.run(DubboDemoConsumerApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-comment">// ApplicationRunner 在程序启动后 执行代码逻辑</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ApplicationRunner <span class="hljs-function"><span class="hljs-title">runner</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> args -&gt; System.out.println(<br>                demoService.sayHello(<span class="hljs-string">&quot;dubbo-springboot&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、Dubbo-Admin"><a href="#4、Dubbo-Admin" class="headerlink" title="4、Dubbo-Admin"></a>4、Dubbo-Admin</h3><p>文档地址：<a href="http://dubbo.apache.org/zh-cn/docs/admin/introduction.html">http://dubbo.apache.org/zh-cn/docs/admin/introduction.html</a></p><p>建议使用前后端分离的部署方案，注意确认代码配置中的zookeeper地址是否正确。<br><img src="images/image-20200728135839019.png" alt="image-20200728135839019"></p><p>因为相关信息是存入到zookeeper维护的，所以本质上admin是连接zk进行查询</p><p>zookeeper中各信息的存储结构</p><img src="images/image-20200728141252292.png" alt="image-20200728141252292" style="zoom:80%;" /><h2 id="（四）使用Netty封装RPC"><a href="#（四）使用Netty封装RPC" class="headerlink" title="（四）使用Netty封装RPC"></a>（四）使用Netty封装RPC</h2><p>解决不同进程间通信的问题</p><img src="images/image-20200728144427633.png" alt="image-20200728144427633" style="zoom:80%;" /><p>使用时的注意事项：<br>1、调用方调用本地函数，传入对应的参数<br>2、RPC框架是通过动态代理的方式，在运行期动态的创建新类，在代理类中实现通信的细节（序列化、协议格式、参数检验等等），处理之后进行网络传输，在提供方接受请求后，继续进行解码和逻辑处理</p><p>重点需要关注的内容：代理、通讯协议、序列化、网络传输</p><img src="images/image-20200728150457988.png" alt="image-20200728150457988" style="zoom:80%;" /><p>客户端调用方法时，底层的逻辑，是通过动态代理的方式获取对应的service，然后调用方法。<br>在实际的代理类中会封装netty客户端的通信，客户端进行初始化操作，然后将协议和参数的数据，发送到服务端处理，服务端接收后，执行对应的逻辑，并将返回结果通过动态代理的方式，返回给客户端。</p><img src="images/image-20200728161239083.png" alt="image-20200728161239083" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>分布式及微服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap总结</title>
    <link href="/2021/12/06/javase/HashMap%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/06/javase/HashMap%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h3 id="1-面试题"><a href="#1-面试题" class="headerlink" title="==1.面试题=="></a>==1.面试题==</h3><h5 id="1-JDK1-8：数组-链表-红黑树"><a href="#1-JDK1-8：数组-链表-红黑树" class="headerlink" title="1.JDK1.8：数组+链表+红黑树"></a>1.JDK1.8：数组+链表+红黑树</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85ZDkyZGRkYS1lZmRiLTRmZjctYTlmYi00MTFjMTY5MzNkYmMucG5n?x-oss-process=image/format,png" alt="img"></p><h5 id="2-插入原理"><a href="#2-插入原理" class="headerlink" title="2.插入原理"></a>2.插入原理</h5><img src="https://img-blog.csdnimg.cn/2020031712385760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nd2FuZ3p3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 80%;" /><p>判断数组是否为空，为空进行初始化;<br>不为空，计算 k 的 hash 值，通过(n - 1) &amp; hash计算应当存放在数组中的下标 index;<br>查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；<br>存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据(onlyIfAbsent为false)；<br>如果不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；(如果当前节点是树型节点证明当前已经是红黑树了)<br>如果不是树型节点，创建普通Node加入链表中；判断链表长度是否大于 8并且数组长度大于64， 大于的话链表转换为红黑树；<br>插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍。</p><h5 id="3-HashMap如何处理哈希碰撞？"><a href="#3-HashMap如何处理哈希碰撞？" class="headerlink" title="3.HashMap如何处理哈希碰撞？"></a>3.HashMap如何处理哈希碰撞？</h5><p>哈希冲突的解决方案有多种:</p><p><strong>开放地址法（发生冲突，继续寻找下一块未被占用的存储地址），</strong></p><p><strong>再散列函数法，建立公共溢出区：把冲突的都放在另一个地方，不在表里面。</strong></p><p><strong>链地址法（JDK1.7 链表，JDK1.8 链表+红黑树）</strong></p><p>而HashMap即是采用了链地址法，也就是数组+链表的方式，</p><p>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p><h5 id="3-HashMap怎么设定初始容量大小的？"><a href="#3-HashMap怎么设定初始容量大小的？" class="headerlink" title="3.HashMap怎么设定初始容量大小的？"></a>3.HashMap怎么设定初始容量大小的？</h5><p> 一般如果<code>new HashMap()</code> 不传值，默认大小是16，负载因子是0.75， 如果自己传入初始大小k，初始化大小为 大于k的 2的整数次方，例如如果传10，大小为16。</p><h5 id="4-HashMap的哈希函数怎么设计的？为什么要这么设计？"><a href="#4-HashMap的哈希函数怎么设计的？为什么要这么设计？" class="headerlink" title="4.HashMap的哈希函数怎么设计的？为什么要这么设计？"></a>4.HashMap的哈希函数怎么设计的？为什么要这么设计？</h5><p>hash函数是先拿到 key 的hashcode，是一个32位的int值，然后让hashcode的高16位和低16位进行异或操作。</p><p>这个也叫扰动函数，这么设计有二点原因：</p><ol><li>一定要尽可能降低hash碰撞，越分散越好；</li><li>算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；</li></ol><h5 id="5-为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？"><a href="#5-为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？" class="headerlink" title="5.为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？"></a>5.为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？</h5><p>​        因为key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。int值范围为**-2147483648~2147483647**，前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。你想，如果HashMap数组的初始大小才16，用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。<br>另外Java1.8相比1.7做了调整，1.7做了四次移位和四次异或，但明显Java 8觉得扰动做一次就够了，做4次的话，多了可能边际效用也不大，所谓为了效率考虑就改成一次了。</p><h5 id="6-1-8对hash函数做了优化，1-8还有别的优化吗？为什么要这么做？"><a href="#6-1-8对hash函数做了优化，1-8还有别的优化吗？为什么要这么做？" class="headerlink" title="6.  1.8对hash函数做了优化，1.8还有别的优化吗？为什么要这么做？"></a>6.  1.8对hash函数做了优化，1.8还有别的优化吗？为什么要这么做？</h5><p>1.数组+链表改成了数组+链表或红黑树；<br>2.链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，原始节点作为新节点的后继节点，1.8遍历链表，将元素放置到链表的最后；<br>3.扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；<br>4.在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；</p><ol><li><p>防止发生hash冲突，链表长度过长，将时间复杂度由<code>O(n)</code>降为<code>O(logn)</code>;</p></li><li><p>因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；</p><p>3.扩容的时候为什么1.8 不用重新hash就可以直接定位原节点在新数据的位置呢?</p></li></ol><p>这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1，怎么理解呢？</p><p>扩容前长度为16，用于计算(n-1) &amp; hash 的二进制n-1为0000 1111，扩容为32后的二进制就高位多了1，为0001 1111。</p><p>因为是&amp; 运算，1和任何数 &amp; 都是它本身，那就分二种情况，如下图：原数据hashcode高位第4位为0和高位为1的情况；</p><p>第四位高位为0，重新hash数值不变，第四位为1，重新hash数值比原来大16（旧数组的容量）</p><h5 id="7-HashMap是线程安全的吗？如果不是怎么解决？"><a href="#7-HashMap是线程安全的吗？如果不是怎么解决？" class="headerlink" title="7.HashMap是线程安全的吗？如果不是怎么解决？"></a>7.HashMap是线程安全的吗？如果不是怎么解决？</h5><p>1.不是，在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有数据覆盖的问题，以1.8为例，当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；还有++size这个地方也会造成多线程同时扩容等问题。</p><ol start="2"><li>Java中有==HashTable==、==Collections.synchronizedMap==、以及==ConcurrentHashMap==可以实现线程安全的Map。</li></ol><p>HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大，</p><p>Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，内部定义了一个对象锁，方法内通过对象锁实现；</p><p>ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。</p><h5 id="8-ConcurrentHashMap的分段锁的实现原理吗？"><a href="#8-ConcurrentHashMap的分段锁的实现原理吗？" class="headerlink" title="8.ConcurrentHashMap的分段锁的实现原理吗？"></a>8.ConcurrentHashMap的分段锁的实现原理吗？</h5><p>ConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。</p><h5 id="9-为什么链表转红黑树的阈值是8，红黑树转链表的阈值是6？"><a href="#9-为什么链表转红黑树的阈值是8，红黑树转链表的阈值是6？" class="headerlink" title="9.为什么链表转红黑树的阈值是8，红黑树转链表的阈值是6？"></a>9.为什么链表转红黑树的阈值是8，红黑树转链表的阈值是6？</h5><p>因为经过计算，在hash函数设计合理的情况下，发生hash碰撞8次的几率为百万分之6，概率说话。。因为8够用了，至于为什么转回来是6，因为如果hash碰撞次数在8附近徘徊，会一直发生链表和红黑树的互相转化，为了预防这种情况的发生。</p><h5 id="10-HashMap内部节点是无序的，根据hash值随机插入，LinkedHashMap-和-TreeMap是有序的Map。"><a href="#10-HashMap内部节点是无序的，根据hash值随机插入，LinkedHashMap-和-TreeMap是有序的Map。" class="headerlink" title="10.HashMap内部节点是无序的，根据hash值随机插入，LinkedHashMap 和 TreeMap是有序的Map。"></a>10.HashMap内部节点是无序的，根据hash值随机插入，LinkedHashMap 和 TreeMap是有序的Map。</h5><h5 id="10-LinkedHashMap怎么实现有序的？"><a href="#10-LinkedHashMap怎么实现有序的？" class="headerlink" title="10.LinkedHashMap怎么实现有序的？"></a>10.LinkedHashMap怎么实现有序的？</h5><p>LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。</p><h5 id="11-TreeMap怎么实现有序的？"><a href="#11-TreeMap怎么实现有序的？" class="headerlink" title="11.TreeMap怎么实现有序的？"></a>11.TreeMap怎么实现有序的？</h5><p>TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。</p><p>所以要么key所属的类实现Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用于key的比较。</p><h5 id="12-HashMap中的Hash码如何计算？为什么要这么做？"><a href="#12-HashMap中的Hash码如何计算？为什么要这么做？" class="headerlink" title="12.HashMap中的Hash码如何计算？为什么要这么做？"></a>12.HashMap中的Hash码如何计算？为什么要这么做？</h5><p>==1.8版本:==</p><p>注意：HashCode（）是对象的Hash码，和HashMap中的Hash码不是同一个东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>h是对象的hashcode，h右移16位也就是取最高位的16位（一共32位）。<br>与原来的hashcode进行异或运算（同0异1）。<br>由此可知又移16位和HashCode的^运算，不对hashCode()的高16位进行改变：1&amp;0=1</p><p>那么这样做的意义何在？</p><p>目的：减少hash碰撞<br>在jvm虚拟机中，一个hashcode位32，那么右移16位进行打乱的^操作，即是对低16位一次打乱，而且混合后的低位掺杂了高位的部分特征，使高位的信息也被保留下来</p><p>==1.7版本:==（功能和1.8版相似）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;<br>h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br><span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="1当key力null时，进行put操作，数据会被放在哪个桶位-为什么"><a href="#1当key力null时，进行put操作，数据会被放在哪个桶位-为什么" class="headerlink" title="1当key力null时，进行put操作，数据会被放在哪个桶位?为什么?"></a>1当key力null时，进行put操作，数据会被放在哪个桶位?为什么?</h4><p>A：会被放在0这个桶位（区别于currentHashMap的判断）</p><h4 id="2为什么HashMap内部的散列表数组长度一定是2的次方数"><a href="#2为什么HashMap内部的散列表数组长度一定是2的次方数" class="headerlink" title="2为什么HashMap内部的散列表数组长度一定是2的次方数"></a>2为什么HashMap内部的散列表数组长度一定是2的次方数</h4><p>A：减少Hash冲突，是内部散列性更好，如果不是2的次方数和key进行运算，会导致Hash冲突会很高，查询性能会很差。</p><h4 id="3-HashMap内部的散列表结构，什么时候初始化，以及初始化大小分别有几种情况"><a href="#3-HashMap内部的散列表结构，什么时候初始化，以及初始化大小分别有几种情况" class="headerlink" title="3.HashMap内部的散列表结构，什么时候初始化，以及初始化大小分别有几种情况?"></a>3.HashMap内部的散列表结构，什么时候初始化，以及初始化大小分别有几种情况?</h4><p>A：四种构造方法，唯一一种对HashMap初始化的就是传入一个Map会初始化，其他三种构造方法都是在put元素的时候才会初始化。</p><h4 id="4-HashMap为什么需要扩容，扩容resize又是如何实现的"><a href="#4-HashMap为什么需要扩容，扩容resize又是如何实现的" class="headerlink" title="4.HashMap为什么需要扩容，扩容resize又是如何实现的?"></a>4.HashMap为什么需要扩容，扩容resize又是如何实现的?</h4><p>A：考虑HashMap查询性能，数组长度太小，不管优化成什么样的数据结构都解决不了元素过多查询效率变慢的问题，所以我们要以牺牲空间换时间的解决方案。</p><p>A：与运算，如果结果为1则存入新扩容的地方，如果结果为0，则还是在原数组。</p><h4 id="5-JDK8中，HashMap为什么引入红黑树？"><a href="#5-JDK8中，HashMap为什么引入红黑树？" class="headerlink" title="5.JDK8中，HashMap为什么引入红黑树？"></a>5.JDK8中，HashMap为什么引入红黑树？</h4><p>A：优化查询过程中产生Hash冲突导致查询性能变慢的问题，如果只用链表的话，链表的最差时间复杂度是O（n）就是全部链子都跑一遍，但是如果优化成红黑树，那么他的最差时间复杂度就是树的高度，也就是O（log n），会省很多我们当前遍历的次数。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2021/12/06/javase/JVM/"/>
    <url>/2021/12/06/javase/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="1-说一下-JVM-的主要组成部分及其作用？"><a href="#1-说一下-JVM-的主要组成部分及其作用？" class="headerlink" title="1.说一下 JVM 的主要组成部分及其作用？"></a>1.说一下 JVM 的主要组成部分及其作用？</h3><p><img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-说一下堆栈的区别？"><a href="#2-说一下堆栈的区别？" class="headerlink" title="2.说一下堆栈的区别？"></a>2.说一下堆栈的区别？</h3><p>物理地址</p><p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。</p><p>比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</p><p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p><p>内存分别</p><p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。</p><p>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p><p>存放的内容</p><p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</p><p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p><p>PS：</p><p>静态变量放在方法区<br>静态的对象还是放在堆。<br>程序的可见度</p><p>堆对于整个应用程序都是共享、可见的。</p><p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式（Java语言）</title>
    <link href="/2021/12/06/javase/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/06/javase/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Java单例模式"><a href="#Java单例模式" class="headerlink" title="Java单例模式"></a>Java单例模式</h1><h3 id="Enum实现单例"><a href="#Enum实现单例" class="headerlink" title="Enum实现单例"></a>Enum实现单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumSingle</span> </span>&#123;<br>    INSTANCE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EnumSingle <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hungry</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Hungry</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Hungry HUNGRY = <span class="hljs-keyword">new</span> Hungry();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Hungry <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> HUNGRY;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyMan</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyMan</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazyMan lazyMan = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(lazyMan==<span class="hljs-keyword">null</span>)&#123;<br>            lazyMan = <span class="hljs-keyword">new</span> LazyMan();<br>        &#125;<br>        <span class="hljs-keyword">return</span> lazyMan;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时线程不安全，解决方法有三种：</p><p>1.在getInstance方法上加同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyMan</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyMan</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazyMan lazyMan = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span>  LazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(lazyMan==<span class="hljs-keyword">null</span>)&#123;<br>            lazyMan = <span class="hljs-keyword">new</span> LazyMan();<br>        &#125;<br>        <span class="hljs-keyword">return</span> lazyMan;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.双重检测锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyMan</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyMan</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazyMan lazyMan = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(lazyMan==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (LazyMan.class)&#123;<br>                <span class="hljs-keyword">if</span>(lazyMan==<span class="hljs-keyword">null</span>)&#123;<br>                    lazyMan = <span class="hljs-keyword">new</span> LazyMan();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lazyMan;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Holder</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Holder <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Holder.getInstance;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">getClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Holder holder = <span class="hljs-keyword">new</span> Holder();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式（Java语言）</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题</title>
    <link href="/2021/12/06/javase/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/12/06/javase/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java笔试题常见："><a href="#Java笔试题常见：" class="headerlink" title="Java笔试题常见："></a>Java笔试题常见：</h1><h3 id="equals与-的区别："><a href="#equals与-的区别：" class="headerlink" title="equals与==的区别："></a>equals与==的区别：</h3><hr><ol><li><p>==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 </p></li><li><p>==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较</p></li><li><p>==指引用是否相同， equals()指的是值是否相同</p></li></ol><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><hr><img src="C:\Users\12631\AppData\Roaming\Typora\typora-user-images\image-20210613200412922.png" alt="image-20210613200412922" style="zoom:200%;" /><p>floor: 求小于参数的最大整数。返回double类型—–n. 地板，地面</p><p>​     例如：Math.floor(-4.2) = -5.0</p><p>-———————————————————-</p><p>ceil:  求大于参数的最小整数。返回double类型—–vt. 装天花板；</p><p>​     例如：Math.ceil(5.6) = 6.0</p><p>-———————————————————-</p><p>round: 对小数进行四舍五入后的结果。返回int类型</p><p>​     例如：Math.round(-4.6) = -5</p><h3 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h3><hr><p><strong>字节流：</strong></p><p>InputStream<br>|– FileInputStream (基本文件流）<br>|– BufferedInputStream<br>|– DataInputStream</p><p>|– ObjectInputStream</p><p><strong>字符流</strong></p><p>Reader<br>|– InputStreamReader (byte-&gt;char 桥梁）<br>|– BufferedReader (常用）<br>Writer<br>|– OutputStreamWriter (char-&gt;byte 桥梁）<br>|– BufferedWriter<br>|– PrintWriter （常用）</p><p>总结：</p><p>stream结尾都是字节流，reader和writer结尾都是字符流 两者的区别就是读写的时候一个是按字节读写，一个是按字符。</p><h3 id="Java类加载的机制"><a href="#Java类加载的机制" class="headerlink" title="Java类加载的机制"></a>Java类加载的机制</h3><hr><p><img src="https://uploadfiles.nowcoder.com/images/20190321/242025553_1553171107811_2A8BFCA92E7F024DFD2F7B0EA602002E" alt="img"></p><h3 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h3><hr><p><strong>substring</strong>  方法将返回一个包含从  <em>start</em>  到最后==（不包含  <em>end</em>  ）==的子字符串的字符串。</p><h3 id="String-Stringbuilder-StringBuffer"><a href="#String-Stringbuilder-StringBuffer" class="headerlink" title="String,Stringbuilder,StringBuffer"></a>String,Stringbuilder,StringBuffer</h3><hr><p><img src="https://img-blog.csdn.net/20180411092400746?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTEwMTE3Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/20180411092328691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTEwMTE3Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>（1）如果要操作少量的数据用 String；</p><p>（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；+</p><p>（3）<strong>单线程操作字符串缓冲区下操作大量数据 StringBuilder</strong></p><h5 id="String比较的问题："><a href="#String比较的问题：" class="headerlink" title="String比较的问题："></a>String比较的问题：</h5><hr><p><img src="C:\Users\12631\AppData\Roaming\Typora\typora-user-images\image-20210618100113336.png" alt="image-20210618100113336"></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL知识点（持续更新...）</title>
    <link href="/2021/12/06/mysql/MYSQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/12/06/mysql/MYSQL%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL刷题知识点："><a href="#MYSQL刷题知识点：" class="headerlink" title="MYSQL刷题知识点："></a>MYSQL刷题知识点：</h1><h3 id="limit-和-offset"><a href="#limit-和-offset" class="headerlink" title="limit 和 offset"></a>limit 和 offset</h3><p>limit n子句表示查询结果返回前n条数据</p><p>offset n表示跳过x条语句</p><p>limit y offset x 分句表示查询结果跳过 x 条数据，读取前 y 条数据</p><p>使用limit和offset，降序排列再返回第二条记录可以得到第二大的值。</p><h3 id="ifull"><a href="#ifull" class="headerlink" title="ifull"></a>ifull</h3><p>ifnull(a,b)函数解释：</p><p>如果value1不是空，结果返回a</p><p>如果value1是空，结果返回b</p><h3 id="SQL-SELECT-DISTINCT-语句"><a href="#SQL-SELECT-DISTINCT-语句" class="headerlink" title="SQL SELECT DISTINCT 语句"></a>SQL SELECT DISTINCT 语句</h3><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p><p>关键词 DISTINCT 用于返回唯一不同的值。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL索引总结</title>
    <link href="/2021/12/06/mysql/MYSQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2021/12/06/mysql/MYSQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL索引（20210603）"><a href="#MYSQL索引（20210603）" class="headerlink" title="MYSQL索引（20210603）"></a>MYSQL索引（20210603）</h1><h2 id="1-索引的分类："><a href="#1-索引的分类：" class="headerlink" title="1.索引的分类："></a>1.索引的分类：</h2><p>==从应用层次上来划分：==</p><p>① 普通索引（单列索引）</p><p>② 复合索引（组合索引）</p><p>③ 唯一索引</p><p>④ 主键索引</p><p>⑤ 全文索引</p><p>⑥ 强制索引</p><p>==从表记录的排列顺序和索引的排列顺序是否一致来划分==</p><p>① 聚集索引：表记录的排列顺序和索引的排列顺序一致。</p><p>② 非聚集索引：表记录的排列顺序和索引的排列顺序不一致。</p><h2 id="2-索引的创建、查询和删除"><a href="#2-索引的创建、查询和删除" class="headerlink" title="2.索引的创建、查询和删除"></a>2.索引的创建、查询和删除</h2><h4 id="①-普通索引（单列索引）index"><a href="#①-普通索引（单列索引）index" class="headerlink" title="① 普通索引（单列索引）index"></a>① 普通索引（单列索引）index</h4><p>普通索引（单列索引）：单列索引是最基本的索引，它没有任何限制。</p><p>（1）直接创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name(col_name);<br></code></pre></td></tr></table></figure><p>（2）修改表结构的方式添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> INDEX index_name(col_name);<br></code></pre></td></tr></table></figure><p>（3）删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br>或者<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> `表名` <span class="hljs-keyword">drop</span> index 索引名;<br></code></pre></td></tr></table></figure><h4 id="②-复合索引（组合索引）index-…"><a href="#②-复合索引（组合索引）index-…" class="headerlink" title="② 复合索引（组合索引）index …"></a>② 复合索引（组合索引）index …</h4><p>复合索引：复合索引是在多个字段上创建的索引。<strong>复合索引遵守“最左前缀”原则</strong>，<strong>即在查询条件中使用了复合索引的第一个字段，索引才会被使用</strong>。因此，在复合索引中索引列的顺序至关重要。</p><p>（1）创建一个复合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index index_name <span class="hljs-keyword">on</span> table_name(col_name1,col_name2,...);<br></code></pre></td></tr></table></figure><p>（2）修改表结构的方式添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">add</span> index index_name(col_name,col_name2,...);<br></code></pre></td></tr></table></figure><h4 id="③-唯一索引-Unique-index"><a href="#③-唯一索引-Unique-index" class="headerlink" title="③ 唯一索引 Unique index"></a>③ 唯一索引 Unique index</h4><p>唯一索引：唯一索引和普通索引类似，主要的区别在于，<strong>唯一索引限制列的值必须唯一，但允许存在空值（只允许存在一条空值）</strong>。</p><p>（1）创建唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建单个索引<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name(col_name);<br><br># 创建多个索引<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name <span class="hljs-keyword">on</span> table_name(col_name,...);<br></code></pre></td></tr></table></figure><p>（2）修改表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 单个<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> index index_name(col_name);<br># 多个<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> index index_name(col_name,...);<br></code></pre></td></tr></table></figure><h4 id="④-主键索引-primary-key"><a href="#④-主键索引-primary-key" class="headerlink" title="④ 主键索引 primary key"></a>④ 主键索引 primary key</h4><p>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</p><p>（1）主键索引(创建表时添加)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `news` (<br>    `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT ,<br>    `title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>    `content` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)  <span class="hljs-keyword">NULL</span> ,<br>    `<span class="hljs-type">time</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> ,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>)<br></code></pre></td></tr></table></figure><p>（2）主键索引(创建表后添加)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tbl_name <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(col_name);<br></code></pre></td></tr></table></figure><h4 id="⑤-全文索引-FULLTEXT"><a href="#⑤-全文索引-FULLTEXT" class="headerlink" title="⑤ 全文索引 FULLTEXT"></a>⑤ 全文索引 FULLTEXT</h4><p>全文搜索在 MySQL 中是一个 FULLTEXT 类型索引。<strong>FULLTEXT 索引在 MySQL 5.6 版本之后支持 InnoDB，而之前的版本只支持 MyISAM 表</strong>。</p><p>（1）创建表的适合添加全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `news` (<br>    `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT ,<br>    `title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>    `content` text  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>    `<span class="hljs-type">time</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> ,<br>     <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>    FULLTEXT (content)<br>)<br></code></pre></td></tr></table></figure><p>（2）修改表结构添加全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> FULLTEXT index_fulltext_content(col_name)<br></code></pre></td></tr></table></figure><p>（3）直接创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> FULLTEXT INDEX index_fulltext_content <span class="hljs-keyword">ON</span> table_name(col_name)<br></code></pre></td></tr></table></figure><h4 id="⑥-强制索引-force-index"><a href="#⑥-强制索引-force-index" class="headerlink" title="⑥ 强制索引 force index"></a>⑥ 强制索引 force index</h4><p>有时，因为使用 MySQL 的优化器机制，原本应该使用索引的优化器，反而选择执行全表扫描或者执行的不是预期的索引。此时，可以通过强制索引的方式引导优化器采取正确的执行计划。</p><p>使用强制索引，SQL 语句只使用建立在 index_col_name 上的索引，而不使用其它的索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_name force index (index_col_name)<br></code></pre></td></tr></table></figure><h2 id="3-聚集索引（B-树索引）"><a href="#3-聚集索引（B-树索引）" class="headerlink" title="3.聚集索引（B+树索引）"></a>3.聚集索引（B+树索引）</h2><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><p>聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。</p><h4 id="2-创建聚集索引："><a href="#2-创建聚集索引：" class="headerlink" title="2.创建聚集索引："></a>2.创建聚集索引：</h4><p>​    MySQL里主键就是聚集索引，就是以主键创建的索引。</p><h4 id="3-聚簇的优点："><a href="#3-聚簇的优点：" class="headerlink" title="3.聚簇的优点："></a>3.聚簇的优点：</h4><p>将相关数据保存在一起，减少磁盘I/O。</p><p>数据访问更快。因为数据和索引保存在一起。</p><p>使用覆盖扫描的查询可以直接使用页结点中的主键值。</p><h4 id="4-聚簇的缺点："><a href="#4-聚簇的缺点：" class="headerlink" title="4.聚簇的缺点："></a>4.聚簇的缺点：</h4><p>限制了提高IO密集型应用的性能，但如果数据全部放在内存中，则访问顺序就没那么重要了，聚簇的优势也没了；</p><p>插入速度严重依赖于插入顺序，按主键的顺序插入是最快的方式，不然就应该在加载完后用opeimize table重新组织一下表；</p><p>代价更高：限制innoDB将被更新的行移动到新的位置；</p><p>当主键被更新或者新数据插入导致行移动的时候，可能面临“页分裂”问题。</p><p>可能导致全表扫描变慢，尤其树数据比较稀疏，且数据不连续时；</p><p>二级索引可能比想象更大，因其包含了引用行的主键列；</p><p>二级索引需要两次查找，而不是一次。</p><p>使用InnoDB应当尽可能地按主键顺序插入数据，并尽可能地使用单调的聚簇键的值来来插入新行。</p><p>最好避免随机的聚簇索引，特别是对于IO密集型的应用。因为随机插入的时候，需要为新的行寻找合适的位置——通常是已有数据的中间位置——并且分配空间。这回增加很多额外的工作，并导致分布不够优化。</p><h2 id="4-非聚集索引（以非主键创建的索引-也叫做二级索引-）"><a href="#4-非聚集索引（以非主键创建的索引-也叫做二级索引-）" class="headerlink" title="4.非聚集索引（以非主键创建的索引(也叫做二级索引)）"></a>4.非聚集索引（以非主键创建的索引(也叫做二级索引)）</h2><p>定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p><p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，分成普通索引，唯一索引，全文索引。</p><p>非聚集索引其实叶子节点除了会存储索引覆盖列的数据，也会存放聚集索引所覆盖的列数据。</p><h2 id="5-索引失效"><a href="#5-索引失效" class="headerlink" title="5.索引失效"></a>5.索引失效</h2><p><strong>1)违反最左匹配原则</strong></p><p>如：建立索引为(a,b)的联合索引，那么只查 where b = 2 则不生效。换句话说：如果建立的索引是(a,b,c)，也只有(a),(a,b),(a,b,c)三种查询可以生效。</p><p><strong>2)遇到范围查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">比如：a<span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> d <span class="hljs-operator">=</span><span class="hljs-number">4</span> 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。<br></code></pre></td></tr></table></figure><p><strong>3)在索引列上做任何操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">left</span>(name,<span class="hljs-number">3</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>4)使用不等于(!= 、&lt;&gt;)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">!=</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p><strong>5)like中以通配符开头(‘%abc’)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>zhangsan’;<br></code></pre></td></tr></table></figure><p><strong>6)字符串不加单引号索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><p><strong>7)or连接索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> ‘<span class="hljs-number">2000</span>’ <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">or</span> pos <span class="hljs-operator">=</span>‘cxy’;<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>==聚集索引和非聚集索引的区别：==</p><ul><li>聚集索引在叶子节点存储的是表中的数据。</li><li>非聚集索引在叶子节点存储的是主键和索引列。</li></ul><p>使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。</p><p>非聚集索引在查询的时候可以的话就避免二次查询，这样性能会大幅提升。</p><p>不是所有的表都适合建立索引，只有数据量大表才适合建立索引，且建立在选择性高的列上面性能会更好。</p><h2 id="6-一些面试题："><a href="#6-一些面试题：" class="headerlink" title="6.一些面试题："></a>6.一些面试题：</h2><ol><li>MongoDB的索引为什么选择B树，而MySQL的索引是B+树？</li></ol><p>因为MongoDB不是传统的关系型数据库，而是以Json格式作为存储的NoSQL非关系型数据库，目的就是高性能、高可用、易扩展。摆脱了关系模型，所以范围查询和遍历查询的需求就没那么强烈了。</p><p>2.<strong>MyISAM存储引擎和InnoDB的索引有什么区别</strong></p><p><strong>==MyISAM存储引擎：==</strong></p><ul><li>主键索引</li></ul><p>MyISAM的索引文件(.MYI)和数据文件(.MYD)文件是分离的，索引文件仅保存记录所在页的指针(物理位置)，通过这些指针来读取页，进而读取被索引的行。</p><p>树中的叶子节点保存的是对应行的物理位置。通过该值，==存储引擎能顺利地进行回表查询，得到一行完整记录==。</p><p>同时，每个叶子也保存了指向下一个叶子的指针，从而方便叶子节点的范围遍历。</p><ul><li>辅助索引</li></ul><p>在MyISAM中，主键索引和辅助索引在结构上没有任何区别，==<strong>只是主键索引要求key是唯一的，而辅助索引的key可以重复</strong>==。</p><p><strong>==Innodb存储引擎:==</strong></p><p>Innodb的主键索引和辅助索引之前提到过，再回顾一次。</p><ul><li>主键索引</li></ul><p>InnoDB主键索引中既存储了主健值，又存储了行数据。</p><ul><li>辅助索引</li></ul><p>对于辅助索引，InnoDB采用的方式是在叶子节点中保存主键值，通过这个主键值来回表查询到一条完整记录，因此按辅助索引检索其实进行了二次查询，效率是没有主键索引高的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL锁总结</title>
    <link href="/2021/12/06/mysql/MYSQL%20%E9%94%81/"/>
    <url>/2021/12/06/mysql/MYSQL%20%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h4 id="MYSQL-锁"><a href="#MYSQL-锁" class="headerlink" title="==MYSQL 锁=="></a>==MYSQL 锁==</h4><p>1.**共享锁(**读锁，S锁)</p><p>开启两个事物：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span><br></code></pre></td></tr></table></figure><p>执行SQL并设置锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> lock1 <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span> lock <span class="hljs-keyword">in</span> share mode;<br></code></pre></td></tr></table></figure><p>修改数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">update lock1 <span class="hljs-keyword">set</span> num <span class="hljs-operator">=</span> <span class="hljs-number">34</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>发现没有结果，结果被阻塞 ，表面不允许对第二个SQL进行操作，也是共享锁的特点。</p><p>2.<strong>排它锁</strong>（写锁，X锁）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> lock1 <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> update<br><br><span class="hljs-keyword">commit</span><br></code></pre></td></tr></table></figure><p>当进行等值查询时，查询的当前条件存在索引时，MYSQL会对存在索引的记录加上排它锁，当其他事物还要操作，不行，等事物结束后，才会释放锁。</p><p>3.<strong>意向锁</strong>（意向排它锁（IX），意向共享锁(IS))（表锁）</p><p>意义：优化行锁，表锁的性能问题。</p><p>​            IX和IS相互之间都是兼容（注意上面两种锁都是互斥的）     </p><p>说明：当A事务对某一行数据加了排它锁后，MYSQL会自动在其整个表上加一个意向排它锁，</p><p>​            这样当B事务对A事务进行操作时，不会先对A事务所执行的每条数据进行排查那几条数据进行了加锁操作，</p><p>​            而在访问表的时候就可以知道该表存在意向锁，这样就可以直接返回进行阻塞而无需对其每条数据进行扫描。</p><p>4.<strong>临间锁</strong>（Next-Key）</p><p>特点：左开右闭 是一个范围查询并且有数据命中（解决幻读）</p><p>5.<strong>间隙锁</strong>(GAP)</p><p>查询没有记录命中，就退化成间隙锁。</p><p>只有可重复度级别才有间隙锁</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多态</title>
    <link href="/2021/12/06/javase/Java%E5%A4%9A%E6%80%81/"/>
    <url>/2021/12/06/javase/Java%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h1><h3 id="1-多态性："><a href="#1-多态性：" class="headerlink" title="1.多态性："></a>1.多态性：</h3><p>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><p>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；<br>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p><h3 id="2-什么是多态机制？Java语言是如何实现多态的？"><a href="#2-什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="2.什么是多态机制？Java语言是如何实现多态的？"></a>2.什么是多态机制？Java语言是如何实现多态的？</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h3 id="3-多态的实现"><a href="#3-多态的实现" class="headerlink" title="3.多态的实现"></a>3.多态的实现</h3><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><p>继承：在多态中必须存在有继承关系的子类和父类。</p><p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p><p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java学习路线（个人总结）持续更新中...</title>
    <link href="/2021/12/06/javase/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88JavaSE%EF%BC%89/"/>
    <url>/2021/12/06/javase/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88JavaSE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第一阶段：JavaSE"><a href="#第一阶段：JavaSE" class="headerlink" title="第一阶段：JavaSE"></a>第一阶段：JavaSE</h2><h4 id="预科阶段（学编程之前你需要了解的知识！）"><a href="#预科阶段（学编程之前你需要了解的知识！）" class="headerlink" title="预科阶段（学编程之前你需要了解的知识！）"></a>预科阶段（学编程之前你需要了解的知识！）</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Markdown语法<br>硬件及冯诺依曼结构<br>windows常用快捷键<br>基本的Dos命令<br>计算机语言发展史<br>...<br></code></pre></td></tr></table></figure><h4 id="入门环境搭建（工欲善其事，必先利其器！）"><a href="#入门环境搭建（工欲善其事，必先利其器！）" class="headerlink" title="入门环境搭建（工欲善其事，必先利其器！）"></a>入门环境搭建（工欲善其事，必先利其器！）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Java的特性和优势<br>Java的三大版本<br>JDK/JRE/JVM<br>安装开发环境<br>编译型和解释型<br>使用IDEA开发<br></code></pre></td></tr></table></figure><h4 id="基础语法学习（基础决定你未来的高度！）"><a href="#基础语法学习（基础决定你未来的高度！）" class="headerlink" title="基础语法学习（基础决定你未来的高度！）"></a>基础语法学习（基础决定你未来的高度！）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">注释/标识符/关键词<br>数据类型及类型转换<br>变量/常量/作用域<br>基本运算符<br>自增自减/常用数学工具<br>逻辑运算符/位运算符/三元运算符<br>包机制/JavaDoc生成文档<br></code></pre></td></tr></table></figure><h4 id="流程控制学习（程序的本质就是这些！）"><a href="#流程控制学习（程序的本质就是这些！）" class="headerlink" title="流程控制学习（程序的本质就是这些！）"></a>流程控制学习（程序的本质就是这些！）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">用户交互Scanner/进阶使用<br><span class="hljs-keyword">if</span>选择结构/Switch选择结构/While循环/DoWhile循环<br>For循环/增强For<br><span class="hljs-built_in">break</span>/<span class="hljs-built_in">continue</span>/goto<br></code></pre></td></tr></table></figure><h4 id="方法详解（封装的思想！）"><a href="#方法详解（封装的思想！）" class="headerlink" title="方法详解（封装的思想！）"></a>方法详解（封装的思想！）</h4><h4 id="数组详解（最简单的数据结构！）"><a href="#数组详解（最简单的数据结构！）" class="headerlink" title="数组详解（最简单的数据结构！）"></a>数组详解（最简单的数据结构！）</h4><h4 id="面向对象编程（Java的精髓OOP！）"><a href="#面向对象编程（Java的精髓OOP！）" class="headerlink" title="面向对象编程（Java的精髓OOP！）"></a>面向对象编程（Java的精髓OOP！）</h4><h4 id="异常处理详情（面对异常不慌张！）"><a href="#异常处理详情（面对异常不慌张！）" class="headerlink" title="异常处理详情（面对异常不慌张！）"></a>异常处理详情（面对异常不慌张！）</h4><h4 id="Java常用类学习（日常开发必备知识！）"><a href="#Java常用类学习（日常开发必备知识！）" class="headerlink" title="Java常用类学习（日常开发必备知识！）"></a>Java常用类学习（日常开发必备知识！）</h4><h4 id="集合框架详解（利用集合高效解决问题！）"><a href="#集合框架详解（利用集合高效解决问题！）" class="headerlink" title="集合框架详解（利用集合高效解决问题！）"></a>集合框架详解（利用集合高效解决问题！）</h4><h4 id="I-O详解（走进流的世界！）"><a href="#I-O详解（走进流的世界！）" class="headerlink" title="I/O详解（走进流的世界！）"></a>I/O详解（走进流的世界！）</h4><h4 id="多线程详解（并发编程初步！）"><a href="#多线程详解（并发编程初步！）" class="headerlink" title="多线程详解（并发编程初步！）"></a>多线程详解（并发编程初步！）</h4><h4 id="网络编程详解（迷人的网络世界！）"><a href="#网络编程详解（迷人的网络世界！）" class="headerlink" title="网络编程详解（迷人的网络世界！）"></a>网络编程详解（迷人的网络世界！）</h4><h4 id="GUI编程（从零开始开发游戏！）"><a href="#GUI编程（从零开始开发游戏！）" class="headerlink" title="GUI编程（从零开始开发游戏！）"></a>GUI编程（从零开始开发游戏！）</h4><h4 id="注解和反射（Java进阶必会技能！）"><a href="#注解和反射（Java进阶必会技能！）" class="headerlink" title="注解和反射（Java进阶必会技能！）"></a>注解和反射（Java进阶必会技能！）</h4><h4 id="JUC并发编程（高并发编程理解！）"><a href="#JUC并发编程（高并发编程理解！）" class="headerlink" title="JUC并发编程（高并发编程理解！）"></a>JUC并发编程（高并发编程理解！）</h4><h4 id="JVM深入研究（大佬成长中必会技能！）"><a href="#JVM深入研究（大佬成长中必会技能！）" class="headerlink" title="JVM深入研究（大佬成长中必会技能！）"></a>JVM深入研究（大佬成长中必会技能！）</h4>]]></content>
    
    
    <categories>
      
      <category>Java学习路线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2021/12/06/javase/Java%E9%9B%86%E5%90%88/"/>
    <url>/2021/12/06/javase/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h3 id="1-集合图"><a href="#1-集合图" class="headerlink" title="1.集合图"></a>1.集合图</h3><p><img src="https://img-blog.csdnimg.cn/20210309011651707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nd2FuZ3p3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-Java各种集合类型的时间复杂度："><a href="#2-Java各种集合类型的时间复杂度：" class="headerlink" title="2.Java各种集合类型的时间复杂度："></a>2.<img src="C:\Users\12631\AppData\Roaming\Typora\typora-user-images\image-20210613200321636.png" alt="image-20210613200321636">Java各种集合类型的时间复杂度：</h3><h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h4><p>有序数组<br>    add(插入)： O(n)+O(n)=O(n) （基于顺序法查找）</p><p>​                         O(log2n)+O(n)=O(n)    （基于二分法查找）</p><p>​    del(删)：O(1) (删除末尾元素)</p><p>​                    O(n)(删除(非末尾元素且元素个数&gt;1))</p><p>​    update(改)：O(n)+O(log(n))<br>​    select(查)：O(1)(按照下标查找)</p><p>​                         O(log(n)(按照数值查找)<br>无序数组<br>​    add(插)：O(n) (空间不足需要开辟)</p><p>​                        O(1)    (空间充足)</p><p>​    del(删)：O(n) (非末尾元素且元素个数大于1)</p><p>​                    O（1）（删除末尾元素）        </p><p>​    update(改)：O(n)(这个n的数量级小)<br>​    select(查)：O(1)(通过index直接定位)</p><h4 id="链表-List"><a href="#链表-List" class="headerlink" title="链表 List"></a>链表 List</h4><ul><li>有序链表<br>add(增)：O(n)<br>del(删)：O(n)<br>update(改)：O(n)<br>select(查)：O(n)</li><li>无序链表<br>add(增)：O(1)<br>del(删)：O(n)<br>update(改)：O(n)<br>select(查)：O(n)</li></ul><h4 id="数组列表-ArrayList"><a href="#数组列表-ArrayList" class="headerlink" title="数组列表 ArrayList"></a>数组列表 ArrayList</h4><p>get() 直接读取下标，复杂度 O(1)</p><p>add(E) 直接在队尾添加，复杂度 O(1)</p><p>add(index, E) 在第n个元素后插入，n后面的元素需要向后移动，复杂度 O(n)</p><p>remove() 删除元素后面的元素需要逐个前移，复杂度 O(n)</p><p>==总结：查  o(1)    增 末尾 o(1)   中间   o(n)    删   o(n)==<br>==移动是消耗时间复杂度的==</p><h4 id="链接列表-LinkedList"><a href="#链接列表-LinkedList" class="headerlink" title="链接列表 LinkedList"></a>链接列表 LinkedList</h4><p>addFirst() 添加队列头部，复杂度 O(1)</p><p>removeFirst() 删除队列头部，复杂度 O(1)</p><p>addLast() 添加队列尾部，复杂度 O(1)</p><p>removeLast() 删除队列尾部，复杂度 O(1)</p><p>getFirst() 获取队列头部，复杂度 O(1)</p><p>getLast() 获取队列尾部，复杂度 O(1)</p><p>get() 获取第n个元素，依次遍历，复杂度O(n)</p><p>add(E) 添加到队列尾部，复杂度O(1)</p><p>add(index, E) 添加到第n个元素后，需要先查找到第n个元素，复杂度O(n)</p><p>remove() 删除元素，修改前后元素节点指针，复杂度O(1)</p><p>==总结：查 O（n） 增 末尾O（1）中间O（n） 删O（1）==</p><h4 id="HashMap-Hashtable-HashSet"><a href="#HashMap-Hashtable-HashSet" class="headerlink" title="HashMap/Hashtable/HashSet"></a>HashMap/Hashtable/HashSet</h4><p>插入或删除：O(1)<br>调整容量：O(n)<br>查询：O(1)</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><strong>TreeSet类型是J2SE中唯一可实现自动排序的类型</strong></p><p><strong>LinkedHashSet</strong><br>   LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺 序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>   LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p><p><strong>HashSet</strong></p><p>add() 复杂度为 O(1)</p><p>remove() 复杂度为 O(1)</p><p>contains() 复杂度为 O(1)</p><p>TreeSet(基于红黑树)</p><p>add() 复杂度为 O(log (n))</p><p>remove() 复杂度为 O(log (n))</p><p>contains() 复杂度为 O(log (n))</p><h3 id="3-数组和链表的区别"><a href="#3-数组和链表的区别" class="headerlink" title="3.数组和链表的区别"></a>3.数组和链表的区别</h3><p>1.各自的优缺点：</p><p>(1)数组的优点：</p><p>i：随机访问性强</p><p>ii：查询速度快</p><p>(2)数组的缺点：</p><p>i：增删速度慢</p><p>ii：可能浪费内存</p><p>iii：内存空间要求高，必须有足够大的连续内存存储空间。</p><p>iiii：数组的大小固定，不能动态扩展。</p><p>(3)链表的优点</p><p>i：插入删除速度快</p><p>ii：大小不固定，可以动态扩展。</p><p>iii：内存利用率高，不会浪费内存</p><p>(4)链表的缺点：</p><p>i：不能随机查找，必须从第一个开始遍历，查找效率低</p><p>集合的分支体系</p><p>Collection        Map<br>以value形式存储        以key-value形式存储<br>List        Set         Queue<br>有序可重复    无序无重复    key无序无重复  value无序可以重复</p><p>java.util包<br>*ArrayList<br>1.底层是利用(动态)数组形式实现    1.5<br>2.ArrayList特点适合遍历轮询   不适合插入删除<br>3.如何构建一个ArrayList对象<br>    无参数构造方法    带默认容量构造方法<br>4.ArrayList中常用的方法<br>    增删改查    add(E e)  remove(index)  set(index value)  get(index)   size()<br>    类中其他常用的方法<br>        addAll并集   removeAll差集   ratainAll交集<br>        indexOf()  lastIndexOf()  contains()  List=subList()<br>        isEmpty()  clear()   ensureCapacity()  iterator();迭代器<br>        toArray(T[] x);  trimToSize();<br>5.泛型<br>    用来规定数据类型<br>    注意:  泛型  造型<br>    在类或接口描述的时候  可以使用某种符号来表示一个未知的类型<br>    在类型使用的时候  需要一个具体类型来代替<br>    注意:  泛型需要使用引用数据类型来代替<br>    1.泛型类  2.泛型接口  3.泛型方法  4.方法参数泛型限制  </p><p>List</p><p>Vector类<br>1.java.util包<br>2.是ArrayList集合的早期版本    (StringBuffer早期  StringBuilder后来)<br>    Vector底层也是利用(动态)数组的形式存储<br>    Vector是线程同步的(synchronized)  安全性高  效率低<br>3.扩容方式与ArrayList不同<br>    默认是扩容2倍   可以通过构造方法创建对象时修改这一机制<br>4.构造方法<br>5.常用方法</p><p>Stack类    栈<br>1.java.util包<br>2.构造方法只有一个无参数<br>3.除了继承自Vacton类的方法外还有特殊的方法<br>    push(E e)将某一个元素压入栈顶(add())<br>    E = pop()将某一个元素从栈顶取出并删掉(E = remove())<br>    E = peek()查看栈顶的一个元素 不删除(get())<br>    boolean = empty()判断栈内元素是否为空(isEmpty())<br>    int = search()查找给定的元素在占中的位置(indexOf())<br>4.中国象棋   悔棋<br>    栈中存储每一次操作的步骤<br>    撤销功能</p><p>Queue接口<br>1.java.util        通常子类LinkedList   ArrayDeque<br>2.通常无参数构造方法创建<br>3.一般方法<br>    add()<br>    element()—-&gt;get()<br>    remove()<br>    boolean = offer(E e);//相当于add    不会抛出异常<br>    E = peek();//相当于 element方法<br>    E = poll();剪短//  相当于remove()<br>4.双十一零点秒杀<br>    所有进入秒杀系统的人存入队列</p><p>ArrayList<br>LinkedList类<br>1.java.util包    自己封装过LinkedBox   内部类Node<T>对象(节点 prev item next)<br>2.底层使用双向链表的数据结构形式来存储<br>    适合于插入或删除  不适合遍历轮询<br>3.构建对象<br>    无参数构造方法   带参数的构造方法(collection)<br>4.常用的方法<br>    增删改查   add()  remove()  set()  get()  size()    offer  poll   peek<br>    手册中提供的其他常用方法<br>    addAll   addFist   addLast()  clear()  contains()<br>    element()  getFirst()  getLast()  indexOf()  lastIndex()<br>    …..<br>5.插入删除的特性是否像想的那样<br>    对比ArrayList  Linked</p><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java常用方法（持续更新...）</title>
    <link href="/2021/12/06/javase/%E5%B8%B8%E7%94%A8API/"/>
    <url>/2021/12/06/javase/%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h4 id="Arrays-fill（-a1-value-）"><a href="#Arrays-fill（-a1-value-）" class="headerlink" title="Arrays.fill（ a1, value ）;"></a>Arrays.fill（ a1, value ）;</h4><p>a1是一个数组变量，value是一个a1中元素数据类型的值，作用：填充a1数组中的每个元素都是value</p><hr><h4 id="Map-getOrDefault"><a href="#Map-getOrDefault" class="headerlink" title="Map.getOrDefault();"></a>Map.getOrDefault();</h4><p>Java中的Map提供了getOrDefault()方法，对不存在的键值提供默认值的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>   map.put(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>);<br>   <span class="hljs-comment">// 存在Key1，返回11</span><br>   System.out.println(map.getOrDefault(<span class="hljs-number">1</span>,<span class="hljs-number">22</span>));<br>   <span class="hljs-comment">// 不存在Key3，返回默认值33</span><br>   System.out.println(map.getOrDefault(<span class="hljs-number">3</span>,<span class="hljs-number">33</span>));<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">11</span><br><span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><hr><h4 id="Java-bitCount-方法"><a href="#Java-bitCount-方法" class="headerlink" title="Java bitCount()方法"></a>Java bitCount()方法</h4><p>java.lang.Integer.bitCount()和java.lang.Long.bitCount()方法返回二进制表示中1的位数。</p><hr><h4 id="输出任意数字的任意进制：Integer-toString-num-7"><a href="#输出任意数字的任意进制：Integer-toString-num-7" class="headerlink" title="输出任意数字的任意进制：Integer.toString(num,7);"></a>输出任意数字的任意进制：Integer.toString(num,7);</h4><hr><h4 id="Java-String-trim（）方法用于从字符串中删除开头和结尾的空格。"><a href="#Java-String-trim（）方法用于从字符串中删除开头和结尾的空格。" class="headerlink" title="Java String trim（）方法用于从字符串中删除开头和结尾的空格。"></a>Java String trim（）方法用于从字符串中删除开头和结尾的空格。</h4><hr><h4 id="list集合的set方法就是在指定的位置加入到集合中-集合的size大小不变。"><a href="#list集合的set方法就是在指定的位置加入到集合中-集合的size大小不变。" class="headerlink" title="list集合的set方法就是在指定的位置加入到集合中,集合的size大小不变。"></a>list集合的set方法就是在指定的位置加入到集合中,集合的size大小不变。</h4><hr><h4 id="Character-isLetter-用于判断指定字符是否为字母。"><a href="#Character-isLetter-用于判断指定字符是否为字母。" class="headerlink" title="Character.isLetter():用于判断指定字符是否为字母。"></a>Character.isLetter():用于判断指定字符是否为字母。</h4><h4 id="Character-isDigit-：用于判断字符c是不是数字形式的字符。"><a href="#Character-isDigit-：用于判断字符c是不是数字形式的字符。" class="headerlink" title="Character.isDigit()：用于判断字符c是不是数字形式的字符。"></a>Character.isDigit()：用于判断字符c是不是数字形式的字符。</h4><hr>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>volatile和synchronized</title>
    <link href="/2021/12/06/javase/volatile%E5%92%8Csynchronized/"/>
    <url>/2021/12/06/javase/volatile%E5%92%8Csynchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="volatile和synchronized的底层实现及不同和CAS的原理"><a href="#volatile和synchronized的底层实现及不同和CAS的原理" class="headerlink" title="volatile和synchronized的底层实现及不同和CAS的原理"></a>volatile和synchronized的底层实现及不同和CAS的原理</h1><h3 id="1-volatitle的特点："><a href="#1-volatitle的特点：" class="headerlink" title="1.volatitle的特点："></a>1.volatitle的特点：</h3><p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>　　2）禁止进行指令重排序。</p><p>​        3)    不保证原子性。</p><h3 id="2-synchronized和volatile的区别"><a href="#2-synchronized和volatile的区别" class="headerlink" title="2.synchronized和volatile的区别"></a>2.synchronized和volatile的区别</h3><p>（1）volatile仅能实现变量的可见性，不能保证原子性，synchronized可以保证变量的可见性和原子性；<br>（2）volatile不会造成线程阻塞，synchronized可能会造成线程阻塞（因为volatile只是将当前变量的值及时告知所有线程（可见性），而synchronized是锁定当前变量不让其它线程访问（可见性和原子性））；<br>（3）volatile仅能使用在变量上，synchronized可以使用在变量和方法上；</p><h3 id="3-什么是CAS？"><a href="#3-什么是CAS？" class="headerlink" title="3.什么是CAS？"></a>3.什么是CAS？</h3><p>CAS是Compare And Swap的简称，是CPU的一个原子操作，CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis知识点（持续更新...）</title>
    <link href="/2021/12/06/redis/%E9%A3%9E%E5%93%A5Redis/"/>
    <url>/2021/12/06/redis/%E9%A3%9E%E5%93%A5Redis/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Redis可以存java对象吗？"><a href="#1-Redis可以存java对象吗？" class="headerlink" title="1.Redis可以存java对象吗？"></a>1.Redis可以存java对象吗？</h3><p>可以。但必须进行序列化。（通过String和Obj对象相互转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(userObj!=<span class="hljs-keyword">null</span>)&#123;<br>        user = JsonUtil.string2Obj(String.valueOf(userObj),User.class);<br>        <span class="hljs-keyword">return</span> R.ok().data(<span class="hljs-string">&quot;user&quot;</span>,user);<br>    &#125;<br>    <span class="hljs-comment">//3.如果不存在就去db查询，并放入redis缓存中。</span><br>    user = userService.getById(id);<br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:&quot;</span>+id, JsonUtil.obj2String(user));<br></code></pre></td></tr></table></figure><h3 id="2-解决SpringBoot整合redis默认以jackJson进行序列化存储的（会出现前缀乱码）"><a href="#2-解决SpringBoot整合redis默认以jackJson进行序列化存储的（会出现前缀乱码）" class="headerlink" title="2.解决SpringBoot整合redis默认以jackJson进行序列化存储的（会出现前缀乱码）"></a>2.解决SpringBoot整合redis默认以jackJson进行序列化存储的（会出现前缀乱码）</h3><p>重写redisTemplate序列化规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>       RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>       redisTemplate.setConnectionFactory(redisConnectionFactory);<br>       <span class="hljs-comment">// 创建一个json的序列化方式</span><br>       GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer();<br>       <span class="hljs-comment">// 设置value用jackjson进行处理</span><br>       redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>       <span class="hljs-comment">// 设置key用string序列化方式</span><br>       redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>       <span class="hljs-comment">// 设置hash的键</span><br>       redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>       <span class="hljs-comment">// 设置hash的value序列化</span><br>       redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>       redisTemplate.afterPropertiesSet();<br>       <span class="hljs-keyword">return</span> redisTemplate;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-亿级并发量redis优化"><a href="#3-亿级并发量redis优化" class="headerlink" title="3.亿级并发量redis优化"></a>3.亿级并发量redis优化</h3><h3 id="4-Redis进行随机读取数据"><a href="#4-Redis进行随机读取数据" class="headerlink" title="4.Redis进行随机读取数据"></a>4.Redis进行随机读取数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">set</span>集合操作：<br>srandmember users <span class="hljs-operator">/</span><span class="hljs-operator">/</span>随机读取一个<span class="hljs-keyword">user</span><br>sadd<span class="hljs-operator">/</span><span class="hljs-operator">/</span>增加<br>srem<span class="hljs-operator">/</span><span class="hljs-operator">/</span>移除<br>sinter<span class="hljs-operator">/</span><span class="hljs-operator">/</span>取交集<br>sunion<span class="hljs-operator">/</span><span class="hljs-operator">/</span>取并集（相同的只保存一份）<br>sdiff<span class="hljs-operator">/</span><span class="hljs-operator">/</span>取差集<br>sismember<span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断是否存在 存在<span class="hljs-number">1</span> 不存在<span class="hljs-number">0</span><br><span class="hljs-comment">---</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>List集合操作:<br>lpush<span class="hljs-operator">/</span><span class="hljs-operator">/</span>增加<br>lrange XX <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>获取指定范围内的元素，<br>linsert xx before<span class="hljs-operator">/</span>after <span class="hljs-number">1</span> aa<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在第一个元素 前<span class="hljs-operator">/</span>后插入<br>lrem key count <span class="hljs-keyword">value</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>把集合里面为<span class="hljs-keyword">value</span>的元素去掉count个<br>lpoplpush <span class="hljs-operator">/</span><span class="hljs-operator">/</span>移除列表中的最后一个元素，并将该元素添加到另一个列表并返回<br>lpop<span class="hljs-operator">/</span><span class="hljs-operator">/</span>弹出最上方的元素<br>B[LR]pop key1 key2 移除并获取列表第一个或者最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出的元素为止。<br><span class="hljs-comment">---</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>hash集合命令:<br>Redis里面的hash格式：key map<span class="hljs-operator">&lt;</span>key,<span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br>hset <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> id <span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>存k<span class="hljs-operator">-</span>v<br>hget <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> id<span class="hljs-operator">/</span><span class="hljs-operator">/</span>根据k取v<br>hmset <span class="hljs-operator">/</span><span class="hljs-operator">/</span>批量存<br>hmget <span class="hljs-operator">/</span><span class="hljs-operator">/</span>批量取<br>hgetall<span class="hljs-operator">/</span><span class="hljs-operator">/</span>全部取hash<br>hlen<span class="hljs-operator">/</span><span class="hljs-operator">/</span>key里面多少个map<br>hincrby <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> age <span class="hljs-number">1</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>给hash中key对应的field的<span class="hljs-keyword">value</span>递增<br>hexists <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> xx xx <span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断hash中key对应的field是否存在<br>hdel <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> xx <span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除一个hash中key对应的field<br>Tip:del <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span>（全部删掉<span class="hljs-keyword">user</span>：<span class="hljs-number">1</span>里面的k<span class="hljs-operator">-</span>v） hdel <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> xx xx xx xx（删除<span class="hljs-keyword">user</span>：<span class="hljs-number">1</span>里面 当xx全覆盖到<span class="hljs-keyword">user</span>：<span class="hljs-number">1</span>里面元素时才等价于del）<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>还有string和zset<br><br> <br></code></pre></td></tr></table></figure><h3 id="5-PostConstruct"><a href="#5-PostConstruct" class="headerlink" title="5.@PostConstruct"></a>5.@PostConstruct</h3><p>放在类上，当前类被IOC容器管理后，加载完毕会执行当前类的方法。</p><h3 id="6-布隆过滤器"><a href="#6-布隆过滤器" class="headerlink" title="6.布隆过滤器"></a>6.布隆过滤器</h3>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Resilience4j</title>
    <link href="/2021/12/06/springcloud/Resilience4j/"/>
    <url>/2021/12/06/springcloud/Resilience4j/</url>
    
    <content type="html"><![CDATA[<h2 id="Resilience4j（Hystrix升级版，官方推荐）"><a href="#Resilience4j（Hystrix升级版，官方推荐）" class="headerlink" title="Resilience4j（Hystrix升级版，官方推荐）"></a>Resilience4j（Hystrix升级版，官方推荐）</h2><p>新一代容错库</p><ul><li>灵感来自与neflix Hystrix，但是专为Java 8和函数式编程而设计核心模块</li></ul><p>核心模块</p><ul><li><p>resilience4j-circuitbreaker: 熔断器</p></li><li><p>resilience4j-ratelimiter: 限流器</p></li><li><p>resilience4j-bulkhead: 隔离器</p></li><li><p>resilience4j-retry: 重试器</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>spring cloud Netflix Zuul</title>
    <link href="/2021/12/06/springcloud/spring%20cloud%20Netflix%20Zuul/"/>
    <url>/2021/12/06/springcloud/spring%20cloud%20Netflix%20Zuul/</url>
    
    <content type="html"><![CDATA[<h2 id="spring-cloud-Netflix-Zuul"><a href="#spring-cloud-Netflix-Zuul" class="headerlink" title="spring cloud Netflix Zuul"></a>spring cloud Netflix Zuul</h2><h4 id="Api网关的三个左右"><a href="#Api网关的三个左右" class="headerlink" title="Api网关的三个左右"></a>Api网关的三个左右</h4><ul><li>简化调用过程：提升性能，减少请求往返次数</li><li>向每个客户端提供最优的API</li><li>系统解耦：客户端与服务端的调用关系解耦，向客户端隐藏了应用如何被划分到微服务的细节，服务独立演进。</li></ul><h4 id="EnableZuulProxy和-EnableZuulServer"><a href="#EnableZuulProxy和-EnableZuulServer" class="headerlink" title="@EnableZuulProxy和@EnableZuulServer"></a>@EnableZuulProxy和@EnableZuulServer</h4><ul><li><p>@EnableZuulProxy简单理解为@EnableZuulServer的增强版</p></li><li><p>当Zuul与==Eureka==、==Ribbon==等组件配合使用时，我们使用的是@EnableZuulProxy注解</p></li><li><p>@EnableZuulServer注解注解提供的内置过滤器==并不是创建一个反向代理服务器==或者尝试与Eureka进行集成</p></li><li><p>当我们使用==其它的注册中心==或者想要==自建路由机制==时可以使用@EnableZuulServer注解</p></li></ul><h4 id="API网关和注册中心，负载均衡，服务容错之间的关系"><a href="#API网关和注册中心，负载均衡，服务容错之间的关系" class="headerlink" title="API网关和注册中心，负载均衡，服务容错之间的关系"></a>API网关和注册中心，负载均衡，服务容错之间的关系</h4><hr><h4 id="Web应用服务器对HTTP请求的处理流程"><a href="#Web应用服务器对HTTP请求的处理流程" class="headerlink" title="Web应用服务器对HTTP请求的处理流程"></a>Web应用服务器对HTTP请求的处理流程</h4><img src="C:\Users\12631\AppData\Roaming\Typora\typora-user-images\image-20211107163844191.png" alt="image-20211107163844191" style="zoom:80%;" /><hr><h2 id="Zuul源码分析："><a href="#Zuul源码分析：" class="headerlink" title="Zuul源码分析："></a>Zuul源码分析：</h2><ul><li><p>ZuulFilter组件核心方法</p><p>filterOrder()：Filter执行顺序，通过数字指定。数字越大，优先级越低</p><p>shouldFilter()：Filter是否需要执行，true代表生效，false代表不生效</p><p>有时需要根据场景动态设置过滤器是否生效时就需要用到该方法</p><p>run()：Filter具体实现逻辑。</p><p>filterType()：Filter类型，内置主要分为PRE、ROUTING、POST和ERROR四种</p></li><li><p>FilterLoader源码分析</p><p>在源码变化时编译、载入和校验过滤器</p><p>DynamicCodeCompiler</p><p>GroovyCompiler </p><p>FilterFactory</p><p>FilterFileManager</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Long&gt; filterClassLastModified = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Long&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, String&gt; filterClassCode = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, String&gt; filterCheck = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, List&lt;ZuulFilter&gt;&gt; hashFiltersByType = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, List&lt;ZuulFilter&gt;&gt;();<br><br><span class="hljs-keyword">private</span> FilterRegistry filterRegistry = FilterRegistry.instance();<br><br><span class="hljs-keyword">static</span> DynamicCodeCompiler COMPILER;<br><br><span class="hljs-keyword">static</span> FilterFactory FILTER_FACTORY = <span class="hljs-keyword">new</span> DefaultFilterFactory();<br></code></pre></td></tr></table></figure><ul><li><p>FilterRegistry</p><p>经典的单例模式来创建FilterRegistry实例</p><p>使用线程安全的ConcurrentHashMap来缓存ZuulFilter</p></li><li><p>RequestContext</p><p>Filter之间没有直接的相互通信，他们是通过一个RequestContext的静态类来进行数据传递</p><p>RequestContext类中有ThreadLocal变量来记录每个Request所需要传递的数据</p></li></ul><hr><h4 id="Zuul过滤器（ZuulFilter）架构："><a href="#Zuul过滤器（ZuulFilter）架构：" class="headerlink" title="Zuul过滤器（ZuulFilter）架构："></a>Zuul过滤器（ZuulFilter）架构：</h4><img src="C:\Users\12631\AppData\Roaming\Typora\typora-user-images\image-20211107164101107.png" alt="image-20211107164101107" style="zoom:80%;" /><h4 id="Zuul四种标准过滤器类型"><a href="#Zuul四种标准过滤器类型" class="headerlink" title="Zuul四种标准过滤器类型"></a>Zuul四种标准过滤器类型</h4><ul><li>PRE：在请求到达目标服务器之前调用，比如身份验证、在集群中选择请求的目标服务器、记录请求日志等</li><li>ROUTING：把用户请求发送给目标服务器。</li><li>POST：在用户请求从目标服务器返回以后执行，比如在返回的响应上面添加响应头信息以及做各种统计等</li><li>ERROR：在其他阶段发生错误时执行该过滤器</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Circuit Beaker</title>
    <link href="/2021/12/06/springcloud/spring%20cloud%20circuit%20Breaker/"/>
    <url>/2021/12/06/springcloud/spring%20cloud%20circuit%20Breaker/</url>
    
    <content type="html"><![CDATA[<h3 id="Spring-Cloud-Circuit-Beaker与服务容错"><a href="#Spring-Cloud-Circuit-Beaker与服务容错" class="headerlink" title="Spring Cloud Circuit Beaker与服务容错"></a>Spring Cloud Circuit Beaker与服务容错</h3><hr><h2 id="1-服务隔离："><a href="#1-服务隔离：" class="headerlink" title="1.服务隔离："></a>1.服务隔离：</h2><h4 id="隔离媒介（资源）："><a href="#隔离媒介（资源）：" class="headerlink" title="隔离媒介（资源）："></a>隔离媒介（资源）：</h4><p>线程（代码级别的集群）：</p><p>客户端请求线程（隔离媒介的访问）：</p><ul><li>独占：各个业务事先分配好线程数，若其中某个业务中断了，剩余业务的线程不影响</li><li>共享：所有业务共享线程池，若某个业务的线程中断，则可能引起雪崩效应。</li></ul><p>进程：</p><p>机房：</p><p>读写分离：</p><h2 id="2-服务降级与服务熔断"><a href="#2-服务降级与服务熔断" class="headerlink" title="2.服务降级与服务熔断"></a>2.服务降级与服务熔断</h2><pre><code>#### 区别：</code></pre><ul><li><p>熔断不依赖下层依赖服务的分级，一旦产生故障就断掉。</p></li><li><p>降级需要对下层依赖的业务分解，把产生故障的丢了，换一个轻量级的方案，是一种退而求其次的方法。</p></li></ul><h2 id="3-服务限流"><a href="#3-服务限流" class="headerlink" title="3.服务限流"></a>3.服务限流</h2><p>所谓限流即流量限制，限流的目的是在遇到流量高峰期或者流量突增时，把流量速率限制在系统所能承受的合理范围内，不至于让系统被高流量击垮。</p><p><strong>常见限流方式</strong></p><ul><li>限制单位时间段内调用量来限流。</li><li>通过限制系统的并发调用程度来限流。</li></ul><hr><ul><li><p>计数器法</p></li><li><p>漏桶算法</p></li><li><p>令牌桶算法</p></li><li><p>限流算法</p></li></ul><h3 id="四大熔断组件"><a href="#四大熔断组件" class="headerlink" title="四大熔断组件"></a>四大熔断组件</h3><ul><li>netflix Hystrix</li><li>Resilience4j（Hystrix升级版，官方推荐）</li><li>Sentinel（Spring cloud alibaba）</li><li>Spring Retry（Spring自带的框架）</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Hystrix</title>
    <link href="/2021/12/06/springcloud/spring%20cloud%20netflix%20Hystrix/"/>
    <url>/2021/12/06/springcloud/spring%20cloud%20netflix%20Hystrix/</url>
    
    <content type="html"><![CDATA[<h3 id="Hystrix源码分析"><a href="#Hystrix源码分析" class="headerlink" title="Hystrix源码分析"></a>Hystrix源码分析</h3><hr><h4 id="HystrixCommand-java核心类："><a href="#HystrixCommand-java核心类：" class="headerlink" title="HystrixCommand.java核心类："></a>HystrixCommand.java核心类：</h4><ul><li>setter()：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务分组的设置        </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> HystrixCommandGroupKey groupKey;<br><span class="hljs-comment">//命令的设置（服务级别的设置）</span><br><span class="hljs-keyword">protected</span> HystrixCommandKey commandKey;<br><span class="hljs-comment">//线程池的设置</span><br><span class="hljs-keyword">protected</span> HystrixThreadPoolKey threadPoolKey;<br><span class="hljs-comment">//命令的属性</span><br><span class="hljs-keyword">protected</span> HystrixCommandProperties.Setter commandPropertiesDefaults;<br><span class="hljs-comment">//线程池的属性</span><br><span class="hljs-keyword">protected</span> HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults;<br></code></pre></td></tr></table></figure><ul><li>run()：实现依赖的业务逻辑（微服务之间的调用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><ul><li>getFallBack()：实现服务回退处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><ul><li>HystrixCiruitBreaker()</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud erueka</title>
    <link href="/2021/12/06/springcloud/spring%20cloud%20erueka/"/>
    <url>/2021/12/06/springcloud/spring%20cloud%20erueka/</url>
    
    <content type="html"><![CDATA[<h3 id="注册中心实现方案"><a href="#注册中心实现方案" class="headerlink" title="注册中心实现方案"></a>注册中心实现方案</h3><hr><table><thead><tr><th>产品</th><th>实现机制</th><th>实现语言</th></tr></thead><tbody><tr><td>Zookeeper</td><td>提供一致性，使用基于Paxos协议的ZAB协议</td><td>Java</td></tr><tr><td>Etcd</td><td>使用Raft协议</td><td>Golang</td></tr><tr><td>Consul</td><td>使用Raft协议，并提供可以直接使用的成品</td><td>Golang</td></tr><tr><td>Eureka</td><td>来自Netflix，采用自身的一套实现机制</td><td>Java</td></tr><tr><td>Nacos</td><td>来自阿里巴巴，采用自身的一套实现机制</td><td>Java</td></tr></tbody></table><h3 id="Spring-Cloud-Netflix-Eureka源码分析"><a href="#Spring-Cloud-Netflix-Eureka源码分析" class="headerlink" title="Spring Cloud Netflix Eureka源码分析"></a>Spring Cloud Netflix Eureka源码分析</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数据模型</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry<br>            = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();<br><span class="hljs-comment">//eureka切入点</span><br>InstanceRegistry extends<br>    LeaseManager&lt;InstanceInfo&gt;<br>    LookupService&lt;String&gt;<br><span class="hljs-comment">//registry核心注册方法：</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(InstanceInfo registrant, <span class="hljs-keyword">int</span> leaseDuration, <span class="hljs-keyword">boolean</span> isReplication)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            read.lock();<br>            <span class="hljs-comment">//1.从已经存储的registry中获取一个服务的定义</span><br>            Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());<br>            REGISTER.increment(isReplication);<br>            <span class="hljs-keyword">if</span> (gMap == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//2.如果获取不到服务定义，就初始化一个map，然后放到registry中</span><br>                <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();<br>                gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);<br>                <span class="hljs-keyword">if</span> (gMap == <span class="hljs-keyword">null</span>) &#123;<br>                    gMap = gNewMap;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//3.如果存在，就根据当前信息找到对应的lease</span><br>            Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());<br>            <span class="hljs-keyword">if</span> (existingLease != <span class="hljs-keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="hljs-keyword">null</span>)) &#123;<br>                <span class="hljs-comment">//4.如果lease能找到，根据当前节点的最新更新时间和注册节点的最新更新时间做比较，如果前面比较晚，已现存实例为准</span><br>                Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();<br>                Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();<br>                logger.debug(<span class="hljs-string">&quot;Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;&quot;</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);<br><br>                <span class="hljs-comment">// this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span><br>                <span class="hljs-comment">// InstanceInfo instead of the server local copy.</span><br>                <span class="hljs-keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;<br>                    logger.warn(<span class="hljs-string">&quot;There is an existing lease and the existing lease&#x27;s dirty timestamp &#123;&#125; is greater&quot;</span> +<br>                            <span class="hljs-string">&quot; than the one that is being registered &#123;&#125;&quot;</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);<br>                    logger.warn(<span class="hljs-string">&quot;Using the existing instanceInfo instead of the new instanceInfo as the registrant&quot;</span>);<br>                    registrant = existingLease.getHolder();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//5.如果lease找不到，代表是新的注册操作，则更新续约相关的时间戳</span><br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.expectedNumberOfClientsSendingRenews &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// Since the client wants to register it, increase the number of clients sending renews</span><br>                        <span class="hljs-keyword">this</span>.expectedNumberOfClientsSendingRenews = <span class="hljs-keyword">this</span>.expectedNumberOfClientsSendingRenews + <span class="hljs-number">1</span>;<br>                        updateRenewsPerMinThreshold();<br>                    &#125;<br>                &#125;<br>                logger.debug(<span class="hljs-string">&quot;No previous lease information found; it is new registration&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//6.新建一个lease并放入map中</span><br>            Lease&lt;InstanceInfo&gt; lease = <span class="hljs-keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);<br>            <span class="hljs-keyword">if</span> (existingLease != <span class="hljs-keyword">null</span>) &#123;<br>                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());<br>            &#125;<br>            gMap.put(registrant.getId(), lease);<br>            <span class="hljs-keyword">synchronized</span> (recentRegisteredQueue) &#123;<br>                recentRegisteredQueue.add(<span class="hljs-keyword">new</span> Pair&lt;Long, String&gt;(<br>                        System.currentTimeMillis(),<br>                        registrant.getAppName() + <span class="hljs-string">&quot;(&quot;</span> + registrant.getId() + <span class="hljs-string">&quot;)&quot;</span>));<br>            &#125;<br>            <span class="hljs-comment">// This is where the initial state transfer of overridden status happens</span><br>            <span class="hljs-keyword">if</span> (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the &quot;</span><br>                                + <span class="hljs-string">&quot;overrides&quot;</span>, registrant.getOverriddenStatus(), registrant.getId());<br>                <span class="hljs-keyword">if</span> (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;<br>                    logger.info(<span class="hljs-string">&quot;Not found overridden id &#123;&#125; and hence adding it&quot;</span>, registrant.getId());<br>                    overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());<br>                &#125;<br>            &#125;<br>            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());<br>            <span class="hljs-keyword">if</span> (overriddenStatusFromMap != <span class="hljs-keyword">null</span>) &#123;<br>                logger.info(<span class="hljs-string">&quot;Storing overridden status &#123;&#125; from map&quot;</span>, overriddenStatusFromMap);<br>                registrant.setOverriddenStatus(overriddenStatusFromMap);<br>            &#125;<br><br>            <span class="hljs-comment">//处理instancestatus，更新服务最新的更新时间，刷选缓存。</span><br>            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);<br>            registrant.setStatusWithoutDirty(overriddenInstanceStatus);<br><br>            <span class="hljs-comment">// If the lease is registered with UP status, set lease service up timestamp</span><br>            <span class="hljs-keyword">if</span> (InstanceStatus.UP.equals(registrant.getStatus())) &#123;<br>                lease.serviceUp();<br>            &#125;<br>            registrant.setActionType(ActionType.ADDED);<br>            recentlyChangedQueue.add(<span class="hljs-keyword">new</span> RecentlyChangedItem(lease));<br>            registrant.setLastUpdatedTimestamp();<br>            invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());<br>            logger.info(<span class="hljs-string">&quot;Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)&quot;</span>,<br>                    registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            read.unlock();<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud nextflix ribbon</title>
    <link href="/2021/12/06/springcloud/spring%20cloud%20netflix%20ribbon/"/>
    <url>/2021/12/06/springcloud/spring%20cloud%20netflix%20ribbon/</url>
    
    <content type="html"><![CDATA[<h3 id="LoadBalance注解"><a href="#LoadBalance注解" class="headerlink" title="@LoadBalance注解"></a>@LoadBalance注解</h3><p>Q：为什么通过@LoadBalance注册创建的RestTemplate就能自动具备客户端负载均衡的能力？</p><p>A：</p><ul><li>@LoadBalanced注解就是用来给RestTemplate添加标记，以便使用负载均衡客户端LoadBalanaceClient来配置他。</li></ul><p>​        在RestTemplate发送请求时，会被LoadBalanceInterceptor拦截</p><ul><li>调用LoadBalancerClient</li><li>依赖于Netflix Ribbon自带的ILoadBalance接口</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Queue类</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Java%20Queue%E7%B1%BB/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Java%20Queue%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<img src="https://img-blog.csdnimg.cn/20190528211906552.png" alt="在这里插入图片描述"  /><h4 id="1、offer-和add-的区别"><a href="#1、offer-和add-的区别" class="headerlink" title="1、offer()和add()的区别"></a>1、offer()和add()的区别</h4><p>add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会==抛出一个 unchecked 异常==，而调用 offer() 方法会返回==false==。可以据此在程序中进行有效的判断！</p><h4 id="2、peek-和element-的区别"><a href="#2、peek-和element-的区别" class="headerlink" title="2、peek()和element()的区别"></a>2、peek()和element()的区别</h4><p>peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回==null==，调用element()方法会==抛出NoSuchElementException异常==。</p><h4 id="3、poll-和remove-的区别"><a href="#3、poll-和remove-的区别" class="headerlink" title="3、poll()和remove()的区别"></a>3、poll()和remove()的区别</h4><p>poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回==null==，而remove()会==抛出NoSuchElementException异常==。</p><hr><p>下面是Java中Queue的一些常用方法：<br>add         增加一个元索                      如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove   移除并返回队列头部的元素     如果队列为空，则抛出一个NoSuchElementException异常<br>element  返回队列头部的元素              如果队列为空，则抛出一个NoSuchElementException异常<br>offer       添加一个元素并返回true        如果队列已满，则返回false<br>poll         移除并返问队列头部的元素     如果队列为空，则返回null<br>peek       返回队列头部的元素              如果队列为空，则返回null<br>put         添加一个元素                       如果队列满，则阻塞<br>take        移除并返回队列头部的元素     如果队列为空，则阻塞</p>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Stack类</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Java%20Stack%E7%B1%BB/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Java%20Stack%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="peek-和pop"><a href="#peek-和pop" class="headerlink" title="peek()和pop()"></a>peek()和pop()</h4><p>java里Stack的peek方法是返回栈顶的元素但不移除它。</p><p>但Stack的pop方法是会移除的。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>N叉树的前中后遍历</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//给定一个 N 叉树，返回其节点值的 前序遍历 。 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;<br>        list.add(root.val);<br>        <span class="hljs-keyword">for</span>(Node node : root.children) postorder(node);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//给定一个 N 叉树，返回其节点值的 后序遍历 。 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorder</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;<br>        <span class="hljs-keyword">for</span>(Node node : root.children) postorder(node);<br>        list.add(root.val);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PriorityQueue（优先队列）</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PriorityQueue%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PriorityQueue%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="PriorityQueue（优先队列）"><a href="#PriorityQueue（优先队列）" class="headerlink" title="PriorityQueue（优先队列）"></a>PriorityQueue（优先队列）</h3><hr><p>解释：每次从优先队列中取出来的元素要么是最大值（最大堆），要么是最小值（最小堆）。</p><ul><li><p>优先队列在Java中的使用的最小堆，意味着每次从队列取出的都是最小的元素。</p></li><li><p>对于任意一个数组下标i，满足：左孩子节点的下标left(i)=2 * i，右孩子节点right(i) = 2 * i+1</p></li><li><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是*log(N)*。</p></li></ul><h2 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><h2 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><h2 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p>​    </p><h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉平衡树</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><h4 id="定义：对于任意一个子树而言，左子树和右子树高度只差不超过1"><a href="#定义：对于任意一个子树而言，左子树和右子树高度只差不超过1" class="headerlink" title="定义：对于任意一个子树而言，左子树和右子树高度只差不超过1."></a>定义：对于任意一个子树而言，左子树和右子树高度只差不超过1.</h4><img src="https://img-blog.csdnimg.cn/20191229163909770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTE0NTg4,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><p>图一，很明显就能看出图1中任何子树的高度差都在没有超过1，</p><h4 id="破坏平衡型的类型分为了四种，分别是LL型、RR型、LR型和RL型（L-left-R-right）。"><a href="#破坏平衡型的类型分为了四种，分别是LL型、RR型、LR型和RL型（L-left-R-right）。" class="headerlink" title="破坏平衡型的类型分为了四种，分别是LL型、RR型、LR型和RL型（L=left,R=right）。"></a>破坏平衡型的类型分为了四种，分别是LL型、RR型、LR型和RL型（L=left,R=right）。</h4><ul><li><p>LL型</p><img src="https://img-blog.csdnimg.cn/20191229165610778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTE0NTg4,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h4 id="二叉搜索锁（BST）满足的性质："><a href="#二叉搜索锁（BST）满足的性质：" class="headerlink" title="二叉搜索锁（BST）满足的性质："></a>二叉搜索锁（BST）满足的性质：</h4><ul><li><strong>每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。</strong></li><li><strong>每个节点中的值必须小于（或等于）存储在其右子树中的任何值。</strong></li></ul><img src="https://img-blog.csdnimg.cn/20200313154148778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxNTc2MzI=,size_16,color_FFFFFF,t_70" alt="Sample" style="zoom:50%;" /><h4 id="如何判断二叉搜索树："><a href="#如何判断二叉搜索树：" class="headerlink" title="如何判断二叉搜索树："></a>如何判断二叉搜索树：</h4><p>（1）当前节点下，其左子树<strong>只包含小于</strong>当前节点的数；</p><p>（2）其右子树<strong>只包含大于</strong>当前节点的数；</p><p>（3）所有左子树右子树必须也是二叉搜索树。</p><hr><h3 id="看到二叉搜索树就想这句话，不会的请背诵："><a href="#看到二叉搜索树就想这句话，不会的请背诵：" class="headerlink" title="看到二叉搜索树就想这句话，不会的请背诵："></a>看到二叉搜索树就想这句话，不会的请背诵：</h3><h3 id="中序遍历二叉搜索树等于遍历有序数组"><a href="#中序遍历二叉搜索树等于遍历有序数组" class="headerlink" title="中序遍历二叉搜索树等于遍历有序数组"></a>中序遍历二叉搜索树等于遍历有序数组</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树刷题顺序LeetCode</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B7%E9%A2%98%E9%A1%BA%E5%BA%8F/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B7%E9%A2%98%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">二叉树理论基础</a></li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树：递归遍历</a></li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：迭代法遍历（不统一方式）</a></li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：迭代吗遍历（统一方式）</a></li><li><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">102.二叉树的层序遍历</a></li><li><a href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html">226.翻转二叉树</a></li><li><a href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html">101.对称二叉树</a></li><li><a href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">104.二叉树的最大深度</a></li><li><a href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html">111.二叉树的最小深度</a></li><li><a href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html">222.完全二叉树的节点个数</a></li><li><a href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html">110.平衡二叉树</a></li><li><a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">257.二叉树的所有路径</a></li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E9%80%92%E5%BD%92%E5%B8%A6%E7%9D%80%E5%9B%9E%E6%BA%AF.html">递归中隐藏回溯</a></li><li><a href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html">404.左叶子之和</a></li><li><a href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html">513.找树左下角的值</a></li><li><a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">112.路径总和</a></li><li><a href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">106.从中序与后序遍历序列构造二叉树</a></li><li><a href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html">654.最大二叉树</a></li><li><a href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html">617.合并二叉树</a></li><li><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">700.二叉搜索树中的搜索</a></li><li><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">98.验证二叉搜索树</a></li><li><a href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">530.二叉搜索树的最小绝对差</a></li><li><a href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">501.二叉搜索树中的众数</a></li><li><a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236.二叉树的最近公共祖先</a></li><li><a href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">235.二叉搜索树的最近公共祖先</a></li><li><a href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html">701.二叉搜索树中的插入操作</a></li><li><a href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">450.删除二叉搜索树中的节点</a></li><li><a href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">669.修剪二叉搜索树</a></li><li><a href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">108.将有序数组转换为二叉搜索树</a></li><li><a href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html">538.把二叉搜索树转换为累加树</a></li><li><a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html">二叉树总结篇</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树前中后遍历</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 定义 postorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要递归调用 postorder(root-&gt;left) 来遍历 root 节点的左子树，然后递归调用postorder(root-&gt;right) 来遍历 root 节点的右子树，最后将 root 节点的值加入答案即可，递归终止的条件为碰到空节点。</span><br><span class="hljs-comment">**/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">OrderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-comment">//前序遍历</span><br>        preOrder(root, result);<br>        <span class="hljs-comment">//中序遍历</span><br>        inorder(root, result);<br>        <span class="hljs-comment">//后序遍历</span><br>        postorder(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><span class="hljs-comment">//前序遍历·递归</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        list.add(root.val);           <span class="hljs-comment">// 注意这一句</span><br>        preOrder(root.left, list);<br>        preOrder(root.right, list);<br>    &#125;<br><span class="hljs-comment">//中序遍历·递归</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        inorder(root.left, list);<br>        list.add(root.val);             <span class="hljs-comment">// 注意这一句</span><br>        inorder(root.right, list);<br>    &#125;<br><span class="hljs-comment">//后序遍历·递归</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        postorder(root.left, list);<br>        postorder(root.right, list);<br>        list.add(root.val);             <span class="hljs-comment">// 注意这一句</span><br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树反转</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8D%E8%BD%AC/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-comment">// 先序遍历--从顶向下交换</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 保存右子树</span><br>            TreeNode rightTree = root.right;<br>            <span class="hljs-comment">// 交换左右子树的位置</span><br>            root.right = invertTree(root.left);<br>            root.left = invertTree(rightTree);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br><br>利用中序遍历<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            invertTree(root.left); <span class="hljs-comment">// 递归找到左节点</span><br>            TreeNode rightNode= root.right; <span class="hljs-comment">// 保存右节点</span><br>            root.right = root.left;<br>            root.left = rightNode;<br>            <span class="hljs-comment">// 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span><br>            invertTree(root.left); <br>    &#125;<br>&#125;<br><br>利用后序遍历<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>            <span class="hljs-comment">// 后序遍历-- 从下向上交换</span><br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            TreeNode leftNode = invertTree(root.left);<br>            TreeNode rightNode = invertTree(root.right);<br>            root.right = leftNode;<br>            root.left = rightNode;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br><br>利用层次遍历<br>   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>            <span class="hljs-comment">// 层次遍历--直接左右交换即可</span><br>            <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>            queue.offer(root);<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>                TreeNode node = queue.poll();<br>                TreeNode rightTree = node.right;<br>                node.right = node.left;<br>                node.left = rightTree;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.offer(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用数据结构的复杂度</title>
    <link href="/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="常用数据结构的复杂度"><a href="#常用数据结构的复杂度" class="headerlink" title="常用数据结构的复杂度"></a>常用数据结构的复杂度</h1><h4 id="1-通用的数据结构的时间复杂度"><a href="#1-通用的数据结构的时间复杂度" class="headerlink" title="1.通用的数据结构的时间复杂度"></a>1.通用的数据结构的时间复杂度</h4><p><img src="https://img-blog.csdnimg.cn/20200416170657693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjE3OTc=,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="2-数组排序算法的时间复杂度"><a href="#2-数组排序算法的时间复杂度" class="headerlink" title="2.数组排序算法的时间复杂度"></a>2.数组排序算法的时间复杂度</h4><p><img src="C:\Users\12631\AppData\Roaming\Typora\typora-user-images\image-20210613200243106.png" alt="image-20210613200243106"></p><p><img src="C:\Users\12631\AppData\Roaming\Typora\typora-user-images\image-20210613200305908.png" alt="image-20210613200305908"></p><h4 id="3-排序算法的稳定性与不稳定性"><a href="#3-排序算法的稳定性与不稳定性" class="headerlink" title="3.排序算法的稳定性与不稳定性"></a>3.排序算法的稳定性与不稳定性</h4><p>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，</p><p>冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题</title>
    <link href="/2021/12/06/%E9%9D%A2%E8%AF%95/JavaSE%EF%BC%88duyi%EF%BC%89%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2021/12/06/%E9%9D%A2%E8%AF%95/JavaSE%EF%BC%88duyi%EF%BC%89%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>JavaWEB</strong></p><h3 id="1-请举例说明等值连接，内连接，左外连接，右外连接的区别"><a href="#1-请举例说明等值连接，内连接，左外连接，右外连接的区别" class="headerlink" title="1.请举例说明等值连接，内连接，左外连接，右外连接的区别"></a>1.请举例说明等值连接，内连接，左外连接，右外连接的区别</h3><p>等值链接在广义笛卡尔积的基础上进行了where条件筛选<br> select * from a，b where a.id=b.id<br> 内链接查询的结果和等值链接一致，不分左右且不能省略inner<br> select * from a inner join b on a.id = b.id<br> 左外链接和右外链接 比等值链接多了一部分的数据<br> a表和b表的出现顺序决定了谁在左谁在右<br> 左/右 后面的表是基准表<br> Select * from a right/left join b on xxx</p><h3 id="2-请说明什么是事务，以及事务的四大特性分别表示什么含义"><a href="#2-请说明什么是事务，以及事务的四大特性分别表示什么含义" class="headerlink" title="2.请说明什么是事务，以及事务的四大特性分别表示什么含义"></a>2.请说明什么是事务，以及事务的四大特性分别表示什么含义</h3><p>要么都成功，要么都失败<br> ACID四大特性：<br> 原子性：一个事务中所有的操作是一个整体，不可再分<br> 一致性：一个用户操作了数据并提交后，另一个用户看到的数据与之前用户看到的效果是一致的<br> 隔离性：指多个用户并罚访问数据时，一个用户操作数据库，另一个用户不能有所干扰<br> 持久性：一个用户操作数据的事物一旦被提交，他对数据库底层真实的改变是永久的，不可返回</p><h3 id="3-请说明事务的4种隔离级别及会产生怎样的问题"><a href="#3-请说明事务的4种隔离级别及会产生怎样的问题" class="headerlink" title="3.请说明事务的4种隔离级别及会产生怎样的问题"></a>3.请说明事务的4种隔离级别及会产生怎样的问题</h3><p>Serializable：最高，避免所有问题的出现，但性能很慢<br> Repeatable read：可重复读，避免脏读，不可重复读<br> Read Committed：读已提交，避免脏读</p><p>Read UnCommitted：读取未提交（所有效果均无法保证）</p><h3 id="4-请写出JDBC连接MySQL数据库的基本流程"><a href="#4-请写出JDBC连接MySQL数据库的基本流程" class="headerlink" title="4.请写出JDBC连接MySQL数据库的基本流程"></a>4.请写出JDBC连接MySQL数据库的基本流程</h3><p>导入驱动jar包</p><p>加载驱动类</p><p>获取链接</p><p>创建状态参数</p><p>执行操作</p><p>关闭</p><h3 id="5-请列举三种JS获取DOM对象的方式，并说明返回值类型"><a href="#5-请列举三种JS获取DOM对象的方式，并说明返回值类型" class="headerlink" title="5.请列举三种JS获取DOM对象的方式，并说明返回值类型"></a>5.请列举三种JS获取DOM对象的方式，并说明返回值类型</h3><p>Document.getElementById选择id </p><p>Document.getElemengtByClassName选择类</p><p>Document.getElemengtByTagName 选择标签</p><h3 id="6-请说明如何实现一个Servlet"><a href="#6-请说明如何实现一个Servlet" class="headerlink" title="6.请说明如何实现一个Servlet"></a>6.请说明如何实现一个Servlet</h3><p>创建一个类，继承HttpServlet</p><p>重写doget或者dopost方法，穿入两个参数HttpservletRequest和HttpServletResponse</p><h3 id="7-请说明Servlet管理机制及生命周期"><a href="#7-请说明Servlet管理机制及生命周期" class="headerlink" title="7.请说明Servlet管理机制及生命周期"></a>7.请说明Servlet管理机制及生命周期</h3><p>通过单例模式的生命周期托管的形式实现</p><p>创建 使用 摧毁</p><p>Init，service（request，response），destroy</p><h3 id="8-请说出HttpServletRequest中的5个常用方法"><a href="#8-请说出HttpServletRequest中的5个常用方法" class="headerlink" title="8.请说出HttpServletRequest中的5个常用方法"></a>8.请说出HttpServletRequest中的5个常用方法</h3><p>GetParamter 获取一个参数</p><p>setAttribute 传入一个参数</p><p>getparamterValues 获取全部参数</p><p>setcharactorEncoding 设置传递回来的字符集</p><p>getRequestDispacher 转发带走信息</p><h3 id="9-请说明访问JSP资源的执行过程"><a href="#9-请说明访问JSP资源的执行过程" class="headerlink" title="9.请说明访问JSP资源的执行过程"></a>9.请说明访问JSP资源的执行过程</h3><p>浏览器url地址栏里写入请求的地址，去到tomcat容器中，解析请求的地址，去servletcontroller里面寻找相应的地址，找到后直接返回给浏览器，如果浏览器的请求携带了参数，则继续进行解析req和resp，通过xml文件去寻找相应的controller，controller类进行取值，调用业务方法，处理完毕后，进行转发或者重定向的操作，如果是转发的话，直接在tomcat内部进行，由jsp解析引擎来解析相应的界面，解析成_JSP.JAVA的文件直接相应回浏览器，如果是重定向的话，会直接出去，进行再一次请求操作。</p><h3 id="10-请说明GET请求和POST请求的区别"><a href="#10-请说明GET请求和POST请求的区别" class="headerlink" title="10.请说明GET请求和POST请求的区别"></a>10.请说明GET请求和POST请求的区别</h3><p>如果什么前提，什么规范都没有的话，是没有区别的。</p><p>理论上的：如果是基于RFC规范的话，get用来获取数据，post用来发送数据</p><p>实现上的：GET的数据在URL上是可见的，POST请求不显示在URL中</p><p>​         GET对长度有显示，POST没有</p><p>​         GET请求后，按后退按，刷新按钮无影响，POST数据会被重新提交</p><p>​         GET历史参数会保存到浏览器中，POST不会保存在浏览器中。</p><p>​         GET安全性较差，POST较安全</p><p>11.请说明forward和redirect区别</p><p>12.请说明Servlet和Filter的区别</p><p>13.请说明Cookie和Session区别</p><p>14.请说明AJAX是什么，并写出原生AJAX基本流程</p><p>15.请说一说你对JSON的理解，并说明后端如何存储，前端如何解析</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题</title>
    <link href="/2021/12/06/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <url>/2021/12/06/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="20210528阿里面试"><a href="#20210528阿里面试" class="headerlink" title="20210528阿里面试"></a>20210528阿里面试</h3><p>1.小明最近了解到了摩尔斯密码，小明有一个摩尔斯密码s由点和划构成，点用（）表示，划用1表示。<br>但是小明发现他的摩尔斯电码已经过期了，需要将他的摩尔斯电码更新到最新版本。<br>小明和工作人员沟通后得到了最新版本的摩尔斯电码t。<br>小明有可以选择将某一位置的0变成1，1变成0，这样的代价是1，或者交换两个位置i,j的元素，这样的代价是|i-j|。<br>小明需要用最少的代价使得小明的摩尔斯电码s变成最新版本的摩尔斯电码t。</p><p>2.字符串数字切割 尽可能有多的3的背书<br>如：输入：2021  2|0|21 输出2 有两段被3整除</p><h3 id="20210602猫眼娱乐"><a href="#20210602猫眼娱乐" class="headerlink" title="20210602猫眼娱乐"></a>20210602猫眼娱乐</h3><p>数据结构（时间复杂度，空间复杂度）<br>​数组和链表（遍历，查找，增加，删除的时间和空间复杂度）<br>​数据库索引 MYSQL！！</p><h3 id="20210604百度面试"><a href="#20210604百度面试" class="headerlink" title="20210604百度面试"></a>20210604百度面试</h3><p>MYSQL 聚集索引和非聚集索引的区别<br>ES 倒排索引<br>单例模式（手写）get<br>反转链表（手写）<br>简单工厂模式和工厂模式的区别<br>抽象工厂模式和简单工厂模式的区别</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
